#+TITLE: Comparison of expression deconvolution approaches
#+SETUPFILE: setup.org
#+OPTIONS: toc:2

* Introduction

  Suppose we have observations \(x_i \sim f(\theta_i), i = 1, \ldots, n\), and
  \(\theta_i \sim g(\cdot)\). /Distribution deconvolution/ is the problem of
  estimating \(g \in \mathcal{G}\) from \(x_1, \ldots, x_n\), assuming \(f\) is known
  ([[https://academic.oup.com/biomet/article/103/1/1/2390141][Efron
  2016]]).

  Recent work suggests that scRNA-seq data follows this generative model
  ([[http://dx.doi.org/10.1073/pnas.1721085115][Wang et al. 2018]]). Here, we
  investigate the trade-off between model complexity/flexibility and
  generalization for different choices of \(\mathcal{G}\) in real data.

* Setup

  #+BEGIN_SRC emacs-lisp :exports none
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(mem="16G",partition="broadwl",venv="scmodes") :dir /scratch/midway2/aksarkar/modes :exports none

  #+RESULTS:
  : Submitted batch job 59945098

  #+NAME: imports
  #+BEGIN_SRC ipython
    import functools as ft
    import multiprocessing as mp
    import numpy as np
    import pandas as pd
    import scipy.stats as st
    import scipy.special as sp
    import scmodes
    import sklearn.model_selection as skms

    import rpy2.robjects.packages
    import rpy2.robjects.pandas2ri
    import rpy2.robjects.numpy2ri

    rpy2.robjects.pandas2ri.activate()
    rpy2.robjects.numpy2ri.activate()

    ashr = rpy2.robjects.packages.importr('ashr')
    descend = rpy2.robjects.packages.importr('descend')
  #+END_SRC

  #+RESULTS: imports
  :RESULTS:
  # Out[1]:
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[2]:
  :END:

  #+BEGIN_SRC ipython
    import colorcet
    import matplotlib.pyplot as plt
    plt.rcParams['figure.facecolor'] = 'w'
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[3]:
  :END:

* Methods
** Distribution deconvolution

   The general form of distribution deconvolution for scRNA-seq is:

   \[ x_{ij} \sim \mathrm{Poisson}(\exp(\mathbf{z}_i' \mathbf{b}_j) \lambda_{ij}) \]

   \[ \lambda_{ij} \sim g_j(\cdot) \]

   where:

   - \(x_{ij}\) is the count of molecules of gene \(j\) in cell \(i\)
   - \(\mathbf{z}_i\) is a \(q\)-vector of covariates for cell \(i\)
   - \(\mathbf{b}_j\) is a \(q\)-vector of confounding effects on gene \(j\)
   - \(\lambda_{ij}\) is proportional to the relative abundance of gene \(j\)
     in cell \(i\)

   The primary inference goal is to recover \(g_j\). A secondary goal could be
   to recover \(\lambda_{ij}\). We can trade off flexibility and complexity of
   \(g_j\) for ease of implementation and speed.

   1. *Point mass:* \(g_j = \delta_\mu\). We mention it for completeness.
   2. *Gamma:* \(g_j = \mathrm{Gamma}(\cdot)\). This leads to the negative
      binomial marginal likelihood, and can be motivated by the empirical
      observation that the counts are overdispersed.
   3. *Point-Gamma:* \(g_j = \pi_j \delta_0(\cdot) + (1 - \pi_j)
      \mathrm{Gamma}(\cdot)\). This leads to the zero-inflated negative
      binomial marginal likelihood, which is still analytic and therefore
      computationally favorable. The inclusion of the point mass can be
      motivated by theory suggesting a biological mechanism for bimodal gene
      expression ([[http://dx.doi.org/10.1126/science.1216379][Munsky et
      al. 2013]], [[http://dx.doi.org/10.1186/gb-2013-14-1-r7][Kim and Marioni
      2013]]).
   4. *Unimodal:* \(g_j\) is some unimodal distribution over non-negative
      reals. In practice, we represent this family of distribution as \(g_j =
      \sum_k \pi_k \mathrm{Uniform}(\cdot; \lambda_0, a_{jk})\), where \(k = 1,
      \ldots, K\) are sufficiently many and \(\lambda_0\) is the mode
      ([[http://dx.doi.org/10.1093/biostatistics/kxw041][Stephens 2016]]).
   5. *Zero-inflated exponential family:* \(g_j = \exp(\mathbf{Q}\alpha -
      \phi(\alpha))\), where \(\mathbf{Q}\) is a
      [[https://en.wikipedia.org/wiki/B-spline][B spline spline basis matrix]]
      for a [[https://en.wikipedia.org/wiki/Cubic_Hermite_spline][natural cubic
      spline]]
      ([[https://www.rdocumentation.org/packages/splines/topics/ns][~ns~
      function]];
      [[https://academic.oup.com/biomet/article/103/1/1/2390141][Efron
      2016]]). The key idea of the method is use spline regression to find the
      sufficient statistic and natural parameters which maximizes the penalized
      likelihood of the observed data. The method has been extended to include
      a point mass on zero ([[http://dx.doi.org/10.1073/pnas.1721085115][Wang
      et al. 2018]]).
   6. *Nonparametric:* \(g_j\) is some distribution over non-negative reals
      ([[https://projecteuclid.org/euclid.aoms/1177728066][Kiefer and Wolfowitz
      1956]]). In practice, we discretize the representation
      ([[https://amstat.tandfonline.com/doi/abs/10.1080/01621459.2013.869224][Koenker
      and Mizera 2014]]). In full detail, we use the representation \(g_j =
      \sum_k \pi_k \mathrm{Uniform}(\cdot; ak, a(k + 1))\), where \(a\) is a
      fixed step size, which allows us to re-use the ~ash~ implementation.

   In order to evaluate methods on their ability to estimate \(g_j\), we hold
   out a validation set, and compute the validation set log likelihood. Based
   on our preliminary experiments, we compare all methods against Gamma.

   The benchmarking code is implemented in the Python package
   [[https://github.com/aksarkar/scmodes][scmodes]].

** Benchmarking data

   As examples of homogeneous cell populations, we use:

   1. Sorted immune cells sequenced on the 10X platform
      ([[https://www.nature.com/articles/ncomms14049][Zheng et al. 2017]])

   2. iPSCs derived from Yoruba LCLs, sequenced on the Fluidigm C1 platform
      ([[https://www.biorxiv.org/content/early/2018/09/23/424192][Sarkar et
      al. 2018]])

   We use the homogeneous cells populations to generate synthetic mixtures with
   known cell type labels.

   As examples of heterogeneous cell populations, we use:

   1. Fresh PBMCs sequenced on the 10X platform
      ([[https://www.nature.com/articles/ncomms14049][Zheng et al. 2017]])

   2. Mouse neuron cells sequenced on the Fluidigm C1 platform
      ([[https://science.sciencemag.org/content/347/6226/1138.full][Zeisel et
      al. 2015]])

* Results
** Homogeneous cell populations
*** Example
    :PROPERTIES:
    :CUSTOM_ID: examples
    :END:

    As an example, use the highest expressed genes in 10K sorted CD8+ cytotoxic
    T cells [[https://www.nature.com/articles/ncomms14049][Zheng et al. 2017]].

    #+BEGIN_SRC ipython
      x = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19')
      xj = pd.Series(x[:,x.mean(axis=0).argmax()])
      size_factor = pd.Series(x.sum(axis=1))
      lam = xj / size_factor
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[4]:
    :END:

    Fit unimodal distribution.

    #+BEGIN_SRC ipython :async t
      unimix_res = ashr.ash_workhorse(
        pd.Series(np.zeros(x.shape[0])),
        1,
        lik=ashr.lik_pois(y=xj, scale=size_factor, link='identity'),
        outputlevel='fitted_g',
        mixsd=pd.Series(np.geomspace(lam.min(), lam.max(), 25)),
        mode=pd.Series([lam.min(), lam.max()]))
      unimix_cdf = ashr.cdf_ash(unimix_res, np.linspace(lam.min(), lam.max(), 1000))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[5]:
    :END:

    Fit NPMLE.

    #+BEGIN_SRC ipython :async t
      K = 200
      grid = np.linspace(lam.min(), lam.max(), K + 1)
      npmle_res = ashr.ash_workhorse(
        pd.Series(np.zeros(x.shape[0])),
        1,
        outputlevel='fitted_g',
        lik=ashr.lik_pois(y=xj, scale=size_factor, link='identity'),
        g=ashr.unimix(pd.Series(np.ones(K) / K), pd.Series(grid[:-1]), pd.Series(grid[1:])))
      npmle_cdf = ashr.cdf_ash(npmle_res, np.linspace(lam.min(), lam.max(), 1000))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[15]:
    :END:

    Fit DESCEND.

    #+BEGIN_SRC ipython
      descend_res = descend.deconvSingle(xj, scaling_consts=size_factor, verbose=False)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[7]:
    :END:

    Fit NB/ZINB.

    #+BEGIN_SRC ipython :eval never :noweb tangle :tangle /project2/mstephens/aksarkar/projects/singlecell-modes/code/fit-nb.py
      import numpy as np
      import pandas as pd
      import scipy.io
      import scmodes
      import scqtl

      x = scmodes.read10x(prefix='/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/')
      size_factor = x.sum(axis=1).reshape(-1, 1)
      onehot = np.ones((x.shape[0], 1))
      design = np.zeros((x.shape[0], 1))
      init = scqtl.tf.fit(
        umi=x.astype(np.float32),
        onehot=onehot.astype(np.float32),
        design=design.astype(np.float32),
        size_factor=size_factor.astype(np.float32),
        learning_rate=1e-3,
        max_epochs=30000,
        verbose=True)
      pd.DataFrame(init[0]).to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-nb-log-mu.txt.gz', compression='gzip', sep='\t')
      pd.DataFrame(init[1]).to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-nb-log-phi.txt.gz', compression='gzip', sep='\t')
      log_mu, log_phi, logodds, nb_llik, zinb_llik = scqtl.tf.fit(
        umi=x.astype(np.float32),
        onehot=onehot.astype(np.float32),
        design=design.astype(np.float32),
        size_factor=size_factor.astype(np.float32),
        learning_rate=1e-3,
        max_epochs=30000,
        warm_start=init[:3],
        verbose=True)
      pd.DataFrame(log_mu).to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-log-mu.txt.gz', compression='gzip', sep='\t')
      pd.DataFrame(log_phi).to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-log-phi.txt.gz', compression='gzip', sep='\t')
      pd.DataFrame(logodds).to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-logodds.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=gpu2 --gres=gpu:1 --mem=16G --time=60:00 --job-name=fit-nb
      #!/bin/bash
      source activate scmodes
      python /project2/mstephens/aksarkar/projects/singlecell-modes/code/fit-nb.py
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 58803475

    #+BEGIN_SRC ipython
      j = str(x.mean(axis=0).argmax())
      nb_log_mu = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-nb-log-mu.txt.gz', sep='\t')
      nb_log_phi = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-nb-log-phi.txt.gz', sep='\t')
      # Gamma (Use MATLAB and MATHEMATICA (b=theta=scale, a=alpha=shape) definition)
      # https://github.com/scipy/scipy/blob/v1.2.1/scipy/stats/_continuous_distns.py#L2479
      gamma_cdf = st.gamma(a=np.exp(-nb_log_phi[j]), scale=np.exp(nb_log_mu[j] + nb_log_phi[j])).cdf(np.linspace(lam.min(), lam.max(), 1000))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[8]:
    :END:

    #+BEGIN_SRC ipython
      zinb_log_mu = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-log-mu.txt.gz', sep='\t')
      zinb_log_phi = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-log-phi.txt.gz', sep='\t')
      zinb_logodds = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-logodds.txt.gz', sep='\t')
      point_gamma_cdf = st.gamma(a=np.exp(-zinb_log_phi[j]), scale=np.exp(zinb_log_mu[j] + zinb_log_phi[j])).cdf(np.linspace(lam.min(), lam.max(), 1000))
      point_gamma_cdf *= sp.expit(-zinb_logodds[j].values)
      point_gamma_cdf += sp.expit(zinb_logodds[j].values)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[9]:
    :END:

    Plot the observed counts and deconvolved distributions.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/deconv-example.png
      cm = plt.get_cmap('Dark2').colors
      fig, ax = plt.subplots(2, 1)
      h = ax[0].hist(xj, bins=np.arange(xj.max() + 1), color='k')
      ax[0].set_xlabel('Molecule count')
      ax[0].set_ylabel('Number of cells')

      ax[1].plot(np.linspace(lam.min(), lam.max(), 1000), gamma_cdf, color=cm[0], lw=1, label='Gamma')
      ax[1].plot(np.linspace(lam.min(), lam.max(), 1000), point_gamma_cdf, color=cm[1], lw=1, label='Point-Gamma')
      ax[1].plot(np.array(unimix_cdf.rx2('x')),
                 np.array(unimix_cdf.rx2('y')).ravel(), c=cm[2], lw=1, label='Unimodal')
      F = np.cumsum(np.array(descend_res.slots['density.points'])[:,1])
      ax[1].plot(np.array(descend_res.slots['density.points'])[:,0],
                 F / F.max(), c=cm[3], lw=1, label='ZIEF')
      ax[1].plot(np.array(npmle_cdf.rx2('x')),
                 np.array(npmle_cdf.rx2('y')).ravel(), c=cm[4], lw=1, label='NPMLE')
      ax[1].set_xlabel('Latent gene expression')
      ax[1].set_ylabel('CDF')

      ax[1].legend(frameon=False)

      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[16]:
    [[file:figure/deconvolution.org/deconv-example.png]]
    :END:

    Print out the histogram for inspection.

    #+BEGIN_SRC ipython
      np.vstack((h[1][:-1], h[0])).T
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[52]:
    #+BEGIN_EXAMPLE
      array([[  0.,   0.],
      [  1.,   1.],
      [  2.,   1.],
      [  3.,   0.],
      [  4.,   0.],
      [  5.,   0.],
      [  6.,   1.],
      [  7.,   0.],
      [  8.,   1.],
      [  9.,   5.],
      [ 10.,   8.],
      [ 11.,   4.],
      [ 12.,   9.],
      [ 13.,   9.],
      [ 14.,   8.],
      [ 15.,  20.],
      [ 16.,  17.],
      [ 17.,  24.],
      [ 18.,  31.],
      [ 19.,  44.],
      [ 20.,  39.],
      [ 21.,  41.],
      [ 22.,  46.],
      [ 23.,  72.],
      [ 24.,  68.],
      [ 25.,  74.],
      [ 26.,  74.],
      [ 27.,  86.],
      [ 28.,  94.],
      [ 29., 114.],
      [ 30.,  96.],
      [ 31., 102.],
      [ 32., 120.],
      [ 33., 132.],
      [ 34., 161.],
      [ 35., 138.],
      [ 36., 159.],
      [ 37., 197.],
      [ 38., 186.],
      [ 39., 210.],
      [ 40., 232.],
      [ 41., 244.],
      [ 42., 284.],
      [ 43., 309.],
      [ 44., 321.],
      [ 45., 332.],
      [ 46., 342.],
      [ 47., 371.],
      [ 48., 349.],
      [ 49., 356.],
      [ 50., 317.],
      [ 51., 343.],
      [ 52., 347.],
      [ 53., 342.],
      [ 54., 308.],
      [ 55., 294.],
      [ 56., 274.],
      [ 57., 272.],
      [ 58., 241.],
      [ 59., 219.],
      [ 60., 191.],
      [ 61., 164.],
      [ 62., 145.],
      [ 63., 144.],
      [ 64., 120.],
      [ 65., 121.],
      [ 66., 100.],
      [ 67.,  95.],
      [ 68.,  69.],
      [ 69.,  62.],
      [ 70.,  53.],
      [ 71.,  47.],
      [ 72.,  52.],
      [ 73.,  32.],
      [ 74.,  35.],
      [ 75.,  36.],
      [ 76.,  30.],
      [ 77.,  28.],
      [ 78.,  20.],
      [ 79.,  27.],
      [ 80.,  26.],
      [ 81.,  21.],
      [ 82.,  12.],
      [ 83.,  12.],
      [ 84.,   9.],
      [ 85.,   7.],
      [ 86.,  12.],
      [ 87.,   8.],
      [ 88.,   9.],
      [ 89.,   6.],
      [ 90.,   4.],
      [ 91.,   5.],
      [ 92.,   2.],
      [ 93.,   2.],
      [ 94.,   2.],
      [ 95.,   3.],
      [ 96.,   1.],
      [ 97.,   2.],
      [ 98.,   2.],
      [ 99.,   0.],
      [100.,   0.],
      [101.,   0.],
      [102.,   1.],
      [103.,   1.],
      [104.,   0.],
      [105.,   0.],
      [106.,   2.]])
    #+END_EXAMPLE
    :END:

    Look at what is going on with NPMLE.

    #+BEGIN_SRC ipython
      res0 = ashr.ash_workhorse(
        pd.Series(np.zeros(x.shape[0])),
        1,
        outputlevel=pd.Series(['fitted_g', 'loglik']),
        lik=ashr.lik_pois(y=xj, scale=size_factor, link='identity'),
        g=ashr.unimix(pd.Series(np.ones(100) / 100), pd.Series(grid[:-1]), pd.Series(grid[1:])))
      res1 = ashr.ash_workhorse(
        pd.Series(np.zeros(x.shape[0])),
        1,
        outputlevel=pd.Series(['fitted_g', 'loglik']),
        lik=ashr.lik_pois(y=xj, scale=size_factor, link='identity'),
        g=ashr.unimix(pd.Series(np.ones(200) / 200), pd.Series(grid[:-1]), pd.Series(grid[1:])))
    #+END_SRC

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/npmle-example.png
      plt.clf()
      plt.gcf().set_size_inches(4, 2)
      grid = np.linspace(lam.min(), lam.max(), 1000)
      plt.plot(grid, np.array(ashr.cdf_ash(res0, grid)[1]).ravel(), label='NPMLE (100 components)', lw=1, c='k')
      plt.plot(grid, np.array(ashr.cdf_ash(res1, grid)[1]).ravel(), label='NPMLE (200 components)', lw=2, ls=':', c='r')
      plt.legend(frameon=False)
      plt.xlabel('Latent gene expression')
      plt.ylabel('CDF')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[40]:
    : Text(0, 0.5, 'CDF')
    [[file:figure/deconvolution.org/npmle-example.png]]
    :END:

    #+BEGIN_SRC ipython
      np.array(res0.rx2('loglik')) - np.array(res1.rx2('loglik'))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[41]:
    : array([0.])
    :END:

*** Run the benchmark
    :PROPERTIES:
    :CUSTOM_ID: homogeneous-results
    :END:

    Run the benchmark.

    #+NAME: run-homogeneous-benchmark-cpu
    #+BEGIN_SRC ipython :eval never
      <<imports>>
      import os
      data = {
        'cytotoxic_t': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True),
        'b_cells': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True),
        'ipsc': lambda: scmodes.dataset.ipsc('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/', n=100, return_df=True),
      }
      cpu_methods = ['unimodal', 'zief', 'npmle']
      tasks = [(d, c) for d in data for c in cpu_methods]
      task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
      with mp.Pool(maxtasksperchild=20) as pool:
        # Important: this needs to be done after initializing the pool to avoid
        # memory duplication
        x = data[task[0]]()
        res = scmodes.benchmark.evaluate_deconv_generalization(x.values, pool=pool, test_size=0.1, random_state=0, methods=[task[1]])
        res.index = x.columns
        res.to_csv(f'/scratch/midway2/aksarkar/modes/{task[0]}-{task[1]}.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=broadwl --mem=32G -a 6-8 -n1 -c28 --exclusive --time=12:00:00 --job-name=benchmark --output=benchmark-cpu.out
      #!/bin/bash
      source activate scmodes
      python <<EOF
      <<run-homogeneous-benchmark-cpu>>
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59511459

    #+NAME: run-homogeneous-benchmark-gpu
    #+BEGIN_SRC ipython :eval never
      <<imports>>
      import os
      data = {
        'cytotoxic_t': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True),
        'b_cells': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True),
        # Important: run the benchmark on all genes
        'ipsc': lambda: scmodes.dataset.ipsc('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/', return_df=True),
      }
      tasks = list(data.keys())
      task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
      x = data[task]()
      res = scmodes.benchmark.evaluate_deconv_generalization(x.values, pool=None, test_size=0.1, random_state=0, methods=['gamma', 'point_gamma'])
      res.index = x.columns
      res.to_csv(f'/scratch/midway2/aksarkar/modes/deconv-generalization/{task}-gpu.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=gpu2 --gres=gpu:1 -a 2 --mem=16G --time=12:00:00 --job-name=benchmark --output=benchmark-gpu.out
      #!/bin/bash
      module load cuda/9.0
      source activate scmodes
      python <<EOF
      <<run-homogeneous-benchmark-gpu>>
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59503539

    Read the results.

    #+BEGIN_SRC ipython
      benchmark = {}
      for data in ('cytotoxic_t', 'b_cells', 'ipsc'):
        benchmark[data] = (
          pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-gpu.txt.gz', index_col=0, sep='\t')
          .merge(pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-unimodal.txt.gz', index_col=0, sep='\t'), left_index=True, right_index=True)
          .merge(pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-zief.txt.gz', index_col=0, sep='\t'), left_index=True, right_index=True)
          .merge(pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-npmle.txt.gz', index_col=0, sep='\t'), left_index=True, right_index=True))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[8]:
    :END:

    Plot the generalization performance of each method.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/homogeneous-benchmark.png
      fig, ax = plt.subplots(1, 3)
      fig.set_size_inches(7, 3)
      for i, k in enumerate(sorted(benchmark.keys())):
        ax[i].boxplot((benchmark[f'{k}'].values - benchmark[f'{k}']['gamma'].values.reshape(-1, 1))[:,1:],
                      widths=0.25, medianprops={'color': 'k'}, flierprops={'marker': '.', 'markersize': 4})
        ax[i].set_xticklabels(['ZIG', 'Unimodal', 'ZIEF', 'NPMLE'], rotation=90)
        ax[i].set_xlabel('Assumed latent dist')
        ax[i].set_title(k)
      ax[0].set_ylabel('Diff val set log lik from Gamma')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[15]:
    [[file:figure/deconvolution.org/homogeneous-benchmark.png]]
    :END:

    Zoom in on the relevant part of the plot.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/homogeneous-benchmark-inset.png
      fig, ax = plt.subplots(1, 3)
      fig.set_size_inches(7, 3)
      for a, k, t in zip(ax, sorted(benchmark.keys()), ('B cells', 'Cytotoxic T cells', 'iPSCs')):
        T = (benchmark[f'{k}'].values - benchmark[f'{k}']['gamma'].values.reshape(-1, 1))[:,1:]
        a.boxplot(T, widths=0.25, medianprops={'color': 'k'}, flierprops={'marker': '.', 'markersize': 4})
        a.axhline(y=0, ls=':', lw=1, c='k')
        a.set_xticklabels(['ZIG', 'Unimodal', 'ZIEF', 'NPMLE'], rotation=90)
        a.set_xlabel('Assumed latent dist')
        a.set_ylim(-20, 1.05 * T.max())
        a.set_title(t)
      ax[0].set_ylabel('Diff val set log lik from Gamma')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[17]:
    [[file:figure/deconvolution.org/homogeneous-benchmark-inset.png]]
    :END:

    *Conclusions:*

    - ZIEF overfits most genes
    - Gamma is adequate for many genes
    - The choice of unimodal discretization matters for computational
      speed. The default in ~ashr~ is flawed;
      [[https://github.com/aksarkar/scmodes/blob/4d84236888daba32a7fee60642f3addd5a34ff9c/scmodes/benchmark/deconvolution.py#L83][our
      choice]] makes the method considerably slower

*** Investigate genes with support for more complex models

    In B cells, several genes are better fit assuming ZIEF.

    #+BEGIN_SRC ipython
      b_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[18]:
    :END:

    #+NAME: read-gene-info
    #+BEGIN_SRC ipython
      gene_info = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-genes.txt.gz', sep='\t', index_col=0)
    #+END_SRC

    #+RESULTS: read-gene-info
    :RESULTS:
    # Out[9]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/b-cell-descend-examples.png
      query = benchmark['b_cells'][benchmark['b_cells']['zief'] > benchmark['b_cells']['gamma']].index
      plt.clf()
      fig, ax = plt.subplots(7, 5, sharey=True, sharex=True)
      fig.set_size_inches(7, 9)
      for a, k in zip(ax.ravel(), query):
        a.hist(b_cells.loc[:,k], bins=np.arange(b_cells.loc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta l$={benchmark['b_cells']['zief'].loc[k] - benchmark['b_cells']['gamma'].loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(gene_info.loc[k, 'name'] if k in gene_info.index else k)
      for y in range(ax.shape[0]):
        ax[y][0].set_ylabel('Num cells')
      for x in range(ax.shape[1]):
        ax[-1][x].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[32]:
    [[file:figure/deconvolution.org/b-cell-descend-examples.png]]
    :END:

    For comparison, consider the gene with the largest difference in validation
    set log likelihood. Deconvolve its gene expression assuming \(g_j =
    \delta_\mu(\cdot)\), using the fact:

    \[ \textstyle\sum_i x_i \sim \mathrm{Poisson}\left(\textstyle\sum_i R_i \mu\right) \]

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/b-cell-descend-pois.example.png
      diff = benchmark['b_cells']['zief'] - benchmark['b_cells']['gamma']
      plt.clf()
      fig, ax = plt.subplots(1, 2, sharey=True)
      fig.set_size_inches(5, 2)
      np.random.seed(1)
      x = b_cells.loc[:,diff.idxmax()]
      scale = b_cells.sum(axis=1)
      mu = x.sum() / scale.sum()
      y = np.random.poisson(lam=scale * mu)
      ax[0].hist(x, bins=np.arange(x.max() + 1), color='k')
      ax[0].set_title('Real data')
      ax[1].hist(y, bins=np.arange(y.max() + 1), color='k')
      ax[1].set_title('Matched Poisson samples')
      ax[0].set_ylabel('Number of cells')
      for a in ax:
        a.set_xlabel('Number of molecules')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[36]:
    [[file:figure/deconvolution.org/b-cell-descend-pois.example.png]]
    :END:

    In T cells, several genes appear to be best fit by ZIEF.

    #+BEGIN_SRC ipython
      cytotoxic_t = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[52]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cytotoxic-t-zief-examples.png
      query = benchmark['cytotoxic_t'][benchmark['cytotoxic_t']['zief'] > benchmark['cytotoxic_t']['gamma']].index
      plt.clf()
      fig, ax = plt.subplots(6, 5, sharey=True, sharex=True)
      fig.set_size_inches(7, 7)
      for a, k in zip(ax.ravel(), query):
        a.hist(cytotoxic_t.loc[:,k], bins=np.arange(cytotoxic_t.loc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta l$={benchmark['cytotoxic_t']['zief'].loc[k] - benchmark['cytotoxic_t']['gamma'].loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(gene_info.loc[k, 'name'] if k in gene_info.index else k)
      for y in range(ax.shape[0]):
        ax[y][0].set_ylabel('Num cells')
      for x in range(ax.shape[1]):
        ax[-1][x].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[56]:
    [[file:figure/deconvolution.org/cytotoxic-t-zief-examples.png]]
    :END:

    In iPSCs, several genes appear to be better fit by unimodal/NPMLE.

    #+BEGIN_SRC ipython :async t
      ipsc_counts = scmodes.dataset.ipsc('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/', n=100, return_df=True)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[38]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/ipsc-unimodal-examples.png
      query = benchmark['ipsc'][benchmark['ipsc']['unimodal'] > benchmark['ipsc']['gamma']].index
      plt.clf()
      fig, ax = plt.subplots(8, 5)
      fig.set_size_inches(8, 10)
      for a, k in zip(ax.ravel(), query):
        h = a.hist(ipsc_counts.loc[:,k], bins=np.arange(ipsc_counts.loc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta l$={benchmark['ipsc']['unimodal'].loc[k] - benchmark['ipsc']['gamma'].loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(gene_info.loc[k, 'name'])
      for y in range(ax.shape[0]):
        ax[y][0].set_ylabel('Num cells')
      for x in range(ax.shape[1]):
        ax[-1][x].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[43]:
    [[file:figure/deconvolution.org/ipsc-unimodal-examples.png]]
    :END:

    - /SLC25A5/ ([[https://www.omim.org/entry/300150][Solute carrier family 25
      member 5]]) codes for a mitochrondrial membrane protein
      ([[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5789311/][Rocha et
      al. 2018]]), and is altered in Parkinson's disease
    - /TXNDC17/ ([[https://www.omim.org/entry/616967][Thioredoxin
      domain-containing protein 17]]) appears to be involved in oxidative
      stress
    - /PCBP2/ ([[https://www.omim.org/entry/601210][Poly(rC)-binding protein
      2]]) is involved in post-transcriptional regulation

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/ipsc-npmle-examples.png
      llik_diff = benchmark['ipsc']['npmle'] - benchmark['ipsc']['gamma']
      query = benchmark['ipsc'].loc[llik_diff > 0].index
      plt.clf()
      fig, ax = plt.subplots(9, 5)
      fig.set_size_inches(8, 10)
      for a, k in zip(ax.ravel(), query):
        a.hist(ipsc_counts.loc[:,k], bins=np.arange(ipsc_counts.loc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta l$={llik_diff.loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(gene_info.loc[k, 'name'])
      for y in range(ax.shape[0]):
        ax[y][0].set_ylabel('Num cells')
      for x in range(ax.shape[1]):
        ax[-1][x].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[49]:
    [[file:figure/deconvolution.org/ipsc-npmle-examples.png]]
    :END:

    *Conclusions:*

    - ZIEF does better for genes which appear very close to Poisson. This could
      be because it the estimation algorithm can better estimate a point mass,
      or because two point masses (one zero and one non-zero) would be optimal.
    - When NPMLE does better than Gamma, unimodal does comparably well. The
      genes where this happens quite clearly exhibit unimodal gene expression.

*** Investigate Gamma vs. Point-Gamma in high-depth data
    :PROPERTIES:
    :CUSTOM_ID: bimodal-example-ipsc
    :END:

    Look at the full benchmark results for NB vs. ZINB (only the GPU
    implementation is suitable for this).

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/homogeneous-nb-zinb-benchmark.png
      plt.clf()
      plt.gcf().set_size_inches(3, 3)
      h = plt.hist(ipsc_res['zinb'] - ipsc_res['nb'], color='k', bins=np.arange(-10, 40, 2))
      plt.xlabel('Diff val set log lik from NB')
      _ = plt.ylabel('Number of genes')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[135]:
    [[file:figure/deconvolution.org/homogeneous-nb-zinb-benchmark.png]]
    :END:

    Print the histogram for inspection.

    #+BEGIN_SRC ipython
      np.vstack((h[1][:-1], h[0])).T.astype(int)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[137]:
    #+BEGIN_EXAMPLE
      array([[ -10,    0],
      [  -8,    0],
      [  -6,    0],
      [  -4,    0],
      [  -2, 4977],
      [   0, 4973],
      [   2,    2],
      [   4,    3],
      [   6,    0],
      [   8,    0],
      [  10,    0],
      [  12,    0],
      [  14,    1],
      [  16,    0],
      [  18,    0],
      [  20,    0],
      [  22,    0],
      [  24,    0],
      [  26,    0],
      [  28,    1],
      [  30,    0],
      [  32,    0],
      [  34,    0],
      [  36,    0]])
    #+END_EXAMPLE
    :END:

    Try to find a case in the full iPSC data where point-Gamma (ZINB) is
    required, by performing likelihood ratio tests against Gamma (NB). Use
    Bonferroni correction to control FWER.

    #+BEGIN_SRC ipython
      ipsc_res = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/ipsc-gpu.txt.gz', index_col=0, sep='\t')
      lrt = st.chi2(1).sf(-2 * (ipsc_res['gamma'] - ipsc_res['point_gamma']))
      ipsc_res[lrt < .05 / lrt.shape[0]]
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[51]:
    #+BEGIN_EXAMPLE
      gamma  point_gamma
      gene
      ENSG00000112530 -2017.717750 -1987.894352
      ENSG00000129824 -1803.651932 -1789.106410
    #+END_EXAMPLE
    :END:

    #+BEGIN_SRC ipython :async t
      ipsc_counts = ipsc(query=list(ipsc_res[lrt < .05 / lrt.shape[0]].index), return_df=True)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[16]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/ipsc-zinb.png
      plt.clf()
      fig, ax = plt.subplots(1, 2)
      fig.set_size_inches(6, 3)
      for a, k in zip(ax, ipsc_counts):
        h = a.hist(ipsc_counts[k], bins=np.arange(ipsc_counts[k].max() + 1), color='k')
        a.set_title(gene_info.loc[k, 'name'])
        a.set_xlabel('Number of molecules')
        a.set_ylabel('Number of cells')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[89]:
    [[file:figure/deconvolution.org/ipsc-zinb.png]]
    :END:

    Print out the histogram for /RPS4Y1/ for inspection.

    #+BEGIN_SRC ipython
      np.vstack((h[1][:-1], h[0])).T
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[91]:
    #+BEGIN_EXAMPLE
      array([[  0., 803.],
      [  1., 309.],
      [  2., 435.],
      [  3., 407.],
      [  4., 383.],
      [  5., 323.],
      [  6., 323.],
      [  7., 239.],
      [  8., 163.],
      [  9., 166.],
      [ 10., 132.],
      [ 11.,  98.],
      [ 12.,  97.],
      [ 13., 106.],
      [ 14.,  95.],
      [ 15.,  95.],
      [ 16.,  94.],
      [ 17., 109.],
      [ 18.,  92.],
      [ 19.,  89.],
      [ 20.,  87.],
      [ 21.,  83.],
      [ 22., 100.],
      [ 23.,  75.],
      [ 24.,  71.],
      [ 25.,  60.],
      [ 26.,  61.],
      [ 27.,  60.],
      [ 28.,  60.],
      [ 29.,  34.],
      [ 30.,  50.],
      [ 31.,  41.],
      [ 32.,  34.],
      [ 33.,  38.],
      [ 34.,  28.],
      [ 35.,  23.],
      [ 36.,  19.],
      [ 37.,  18.],
      [ 38.,  11.],
      [ 39.,   7.],
      [ 40.,  17.],
      [ 41.,   8.],
      [ 42.,  12.],
      [ 43.,   7.],
      [ 44.,   4.],
      [ 45.,  11.],
      [ 46.,   4.],
      [ 47.,   2.],
      [ 48.,   1.],
      [ 49.,   3.],
      [ 50.,   1.],
      [ 51.,   1.],
      [ 52.,   2.],
      [ 53.,   1.],
      [ 54.,   1.],
      [ 55.,   1.],
      [ 56.,   2.],
      [ 57.,   0.],
      [ 58.,   0.],
      [ 59.,   0.],
      [ 60.,   0.],
      [ 61.,   0.],
      [ 62.,   0.],
      [ 63.,   0.],
      [ 64.,   0.],
      [ 65.,   1.]])
    #+END_EXAMPLE
    :END:

    /PACRG/ ([[https://www.omim.org/entry/608427][Parkin coregulated gene]])
    shares a promoter with /PKRG/ (/PARK2/;
    [[https://www.omim.org/entry/602544?search=park2&highlight=park2][Parkin]]). PARKIN
    is involved in a [[https://www.pnas.org/content/115/2/E180][signaling
    pathway for mitochondria damage]], and mitochrondrial damage appears to be
    relevant to neurodegenerative disease etiology
    ([[https://www.ncbi.nlm.nih.gov/pubmed/29414602][Alzheimer's disease]] and
    [[https://www.pnas.org/content/115/2/E180][Parkinson's disease]]).
    Mitochrondrial damage could explain the bimodal distribution of /PACRG/ in
    the iPSC data: the reprogramming protocol could induce oxidative stress on
    some of the cells, resulting in damage.

    /RPS4Y1/ ([[https://www.omim.org/entry/470000][Ribosomal protein S4,
    Y-linked]]) is on the Y chromosome, and therefore we should expect it to
    only be expressed in males. The homologous gene on the X chromosome
    ([[https://www.omim.org/entry/312760][/RPS4X/]]) has a different coding
    sequence. Naively, sex-linkage should explain why this gene exhibits bimodal
    gene expression.

    #+BEGIN_SRC sh :dir /project2/mstephens/aksarkar/projects/singlecell-modes/data/
      curl -OL 'http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/working/20130606_sample_info/20130606_sample_info.txt'
    #+END_SRC

    #+RESULTS:

    #+BEGIN_SRC ipython :async t
      donor_info = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/20130606_sample_info.txt', sep='\t')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[64]:
    :END:

    Count how many cells come from females.

    #+BEGIN_SRC ipython
      prefix = '/project2/mstephens/aksarkar/projects/singlecell-qtl/data/'
      annotations = pd.read_csv(f'{prefix}/scqtl-annotation.txt', sep='\t')
      keep_samples = pd.read_csv(f'{prefix}/quality-single-cells.txt', sep='\t', index_col=0, header=None)
      annotations = annotations.loc[keep_samples.values.ravel()]
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[17]:
    :END:

    #+BEGIN_SRC ipython
      annotations.merge(donor_info, left_on='chip_id', right_on='Sample')['Gender'].value_counts()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[100]:
    #+BEGIN_EXAMPLE
      female    3109
      male      2369
      Name: Gender, dtype: int64
    #+END_EXAMPLE
    :END:

    Look at the fitted ZINB distribution per-individual for this gene.

    #+BEGIN_SRC ipython
      ipsc_log_mu = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz', sep=' ', index_col=0)
      ipsc_log_phi = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz', sep=' ', index_col=0)
      ipsc_logodds = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz', sep=' ', index_col=0)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[10]:
    :END:

    #+BEGIN_SRC ipython
      def point_gamma_cdf(grid, log_mu, log_phi, logodds):
        res = st.gamma(a=np.exp(-log_phi), scale=np.exp(log_mu + log_phi)).cdf(grid)
        res *= sp.expit(-logodds)
        res += sp.expit(logodds)
        return res

      lam = ipsc_counts.values / annotations['mol_hs'].values.reshape(-1, 1)
      grid = np.linspace(lam.min(), lam.max(), 1000)
      cdfs = np.array([[point_gamma_cdf(grid,
                                        ipsc_log_mu.loc[j, k],
                                        ipsc_log_phi.loc[j, k],
                                        ipsc_logodds.loc[j, k])
                        for k in ipsc_log_mu]
                       for j in ipsc_counts.columns
                       if j != list(ipsc_log_mu.columns).index('NA18498')])
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[50]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/ipsc-point-gamma-cdf-pacrg.png
      plt.clf()
      fig, ax = plt.subplots(2, 1, sharex=True)
      fig.set_size_inches(6, 4)
      for a, F, k in zip(ax, cdfs, ipsc_counts.columns):
        for f in F:
          a.set_xlim(0, 2e-4)
          a.set_xticks(np.linspace(0, 2e-4, 3))
          a.plot(grid, f, c='k', lw=1, alpha=0.2)
        a.set_title(gene_info.loc[k, 'name'])
        a.set_ylabel('CDF')
      ax[-1].set_xlabel('Latent gene expression')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[63]:
    [[file:figure/deconvolution.org/ipsc-point-gamma-cdf-pacrg.png]]
    :END:

    Plot the estimated /RPS4Y1/ latent gene expression, stratified by donor sex.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/ipsc-point-gamma-cdf-rps4y1.png
      colors = {k: 'r' if v == 'male' else 'b' for k, v in
                donor_info.set_index('Sample')
                .filter(items=list(ipsc_log_mu.columns), axis=0)
                ['Gender']
                .iteritems()}
      plt.clf()
      plt.gcf().set_size_inches(3, 2)
      for f, k in zip(cdfs[1], ipsc_log_mu.columns):
        plt.xlim(0, 2e-4)
        plt.xticks(np.linspace(0, 2e-4, 3))
        plt.plot(grid, f, lw=1, alpha=0.2, c=colors.get(k, 'k'))
        dummy = [plt.Line2D([0], [0], c='r'), plt.Line2D([0], [0], c='b')]
        plt.legend(dummy, ['Male', 'Female'], frameon=False)
        plt.title('RPS4Y1')
        plt.ylabel('CDF')
        plt.xlabel('Latent gene expression')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[99]:
    [[file:figure/deconvolution.org/ipsc-point-gamma-cdf-rps4y1.png]]
    :END:

** Synthetic cell mixtures
*** T cell-B cell mixture

    Create a synthetic heterogeneous population of cells by combining sorted
    CD8+ T cells and CD19+ B cells from
    [[https://www.nature.com/articles/ncomms14049][Zheng et al. 2017]].

    #+NAME: run-synthetic-mix-benchmark-gpu
    #+BEGIN_SRC ipython :eval never
      <<imports>>
      t_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True)
      b_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True)
      x, y = scmodes.dataset.synthetic_mix(t_cells, b_cells)
      res = scmodes.benchmark.evaluate_deconv_generalization(x.values, stratify=y, pool=None, train_size=0.5, test_size=0.1, random_state=0, methods=['gamma', 'point_gamma'])
      res.to_csv(f'/scratch/midway2/aksarkar/modes/deconv-generalization/cd8-cd19-mix-gpu.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
     sbatch --partition=gpu2 --gres=gpu:1 --mem=16G --time=12:00:00 --job-name=benchmark --output=benchmark-gpu.out
     #!/bin/bash
     module load cuda/9.0
     source activate scmodes
     python <<EOF
     <<run-synthetic-mix-benchmark-gpu>>
     EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59527545

    #+NAME: run-synthetic-mix-benchmark-cpu
    #+BEGIN_SRC ipython :eval never
      <<imports>>
      import os
      tasks = ['unimodal', 'zief', 'npmle']
      task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
      with mp.Pool() as pool:
        t_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True)
        b_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True)
        x, y = scmodes.dataset.synthetic_mix(t_cells, b_cells)
        res = scmodes.benchmark.evaluate_deconv_generalization(x.values, stratify=y, pool=pool, train_size=0.5, test_size=0.1, random_state=0, methods=[task])
        res.to_csv(f'/scratch/midway2/aksarkar/modes/deconv-generalization/cd8-cd19-mix-{task}.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
     sbatch --partition=broadwl -a 0-2 -n1 -c28 --exclusive --mem=16G --time=12:00:00 --job-name=benchmark --output=benchmark-cpu.out
     #!/bin/bash
     module load cuda/9.0
     source activate scmodes
     python <<EOF
     <<run-synthetic-mix-benchmark-cpu>>
     EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59557827

*** Naive/activated T cell mixture

    Create a synthetic mixture of cells by combining sorted
    CD8+ cytotoxic T cells and CD8+/CD45RA+ naive cytotoxic T cells
    [[https://www.nature.com/articles/ncomms14049][Zheng et al. 2017]].

    #+NAME: cyto-naive-mix
    #+BEGIN_SRC ipython
      cyto = scmodes.dataset.read_10x(prefix='/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19', return_df=True)
      naive = scmodes.dataset.read_10x(prefix='/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/naive_cytotoxic/filtered_matrices_mex/hg19', return_df=True)
      x, y = scmodes.dataset.synthetic_mix(cyto, naive)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[3]:
    :END:

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=gpu2 --gres=gpu:1 --mem=16G --time=1:00:00 --job-name=benchmark --output=benchmark-gpu.out
      #!/bin/bash
      source activate scmodes
      python <<EOF
      <<imports>>
      <<cyto-naive-mix>>
      res = scmodes.benchmark.evaluate_deconv_generalization(x.values, pool=None, stratify=y, train_size=0.5, test_size=0.1, random_state=0, methods=['gamma', 'point_gamma'])
      res.index = x.columns
      res.to_csv(f'/scratch/midway2/aksarkar/modes/deconv-generalization/cyto-naive-t-mix-gpu.txt.gz', compression='gzip', sep='\t')
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59557262

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=broadwl -a 0 -n1 -c28 --exclusive --mem=16G --time=24:00:00 --job-name=benchmark --output=benchmark-cpu.out
      #!/bin/bash
      source activate scmodes
      python <<EOF
      <<imports>>
      import os
      tasks = ['unimodal', 'zief', 'npmle']
      task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
      with mp.Pool(maxtasksperchild=10) as pool:
        <<cyto-naive-mix>>
        res = scmodes.benchmark.evaluate_deconv_generalization(x.values, pool=pool, stratify=y, train_size=0.5, test_size=0.1, random_state=0, methods=[task])
        res.index = x.columns
        res.to_csv(f'/scratch/midway2/aksarkar/modes/deconv-generalization/cyto-naive-t-mix-{task}.txt.gz', compression='gzip', sep='\t')
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59642575

*** Plot the results

    Read the results.

    #+BEGIN_SRC ipython
      benchmark = {}
      for data in ('cd8-cd19-mix', 'cyto-naive-t-mix'):
        benchmark[data] = (
          pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-gpu.txt.gz', index_col=0, sep='\t')
          .merge(pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-unimodal.txt.gz', index_col=0, sep='\t'), left_index=True, right_index=True)
          .merge(pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-zief.txt.gz', index_col=0, sep='\t'), left_index=True, right_index=True)
          .merge(pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-npmle.txt.gz', index_col=0, sep='\t'), left_index=True, right_index=True))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[4]:
    :END:

    Plot the results.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/synthetic-mix-benchmark.png
      fig, ax = plt.subplots(1, 2, sharey=True)
      fig.set_size_inches(5, 3)
      for a, k, t in zip(ax, sorted(benchmark.keys()), ['T cell/B cell', 'Cytotoxic/Naive T cell']):
        a.boxplot((benchmark[f'{k}'].values - benchmark[f'{k}']['gamma'].values.reshape(-1, 1))[:,1:],
                  widths=0.25, medianprops={'color': 'k'}, flierprops={'marker': '.', 'markersize': 4})
        a.set_xticklabels(['ZIG', 'Unimodal', 'ZIEF', 'NPMLE'], rotation=90)
        a.set_xlabel('Assumed latent dist')
        a.set_title(t)
      ax[0].set_ylabel('Diff val set log lik from Gamma')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[5]:
    [[file:figure/deconvolution.org/synthetic-mix-benchmark.png]]
    :END:

    Zoom in on the relevant part of the plot.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/synthetic-mix-benchmark-inset.png
      fig, ax = plt.subplots(1, 2)
      fig.set_size_inches(5, 3)
      for a, k, t in zip(ax, sorted(benchmark.keys()), ['T cell/B cell', 'Cytotoxic/Naive T cell']):
        T = (benchmark[f'{k}'].values - benchmark[f'{k}']['gamma'].values.reshape(-1, 1))[:,1:]
        a.boxplot(T, widths=0.25, medianprops={'color': 'k'}, flierprops={'marker': '.', 'markersize': 4})
        a.axhline(y=0, ls=':', lw=1, c='k')
        a.set_xticklabels(['ZIG', 'Unimodal', 'ZIEF', 'NPMLE'], rotation=90)
        a.set_xlabel('Assumed latent dist')
        a.set_ylim(-20, 1.05 * T.max())
        a.set_title(t)
      ax[0].set_ylabel('Diff val set log lik from Gamma')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[5]:
    [[file:figure/deconvolution.org/synthetic-mix-benchmark-inset.png]]
    :END:

*** Investigate genes favoring more complex models

    Read the data.

    #+BEGIN_SRC ipython :async t
      t_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True)
      b_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True)
      mix1, y1 = scmodes.dataset.synthetic_mix(t_cells, b_cells)

      cyto = scmodes.dataset.read_10x(prefix='/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19', return_df=True)
      naive = scmodes.dataset.read_10x(prefix='/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/naive_cytotoxic/filtered_matrices_mex/hg19', return_df=True)
      mix2, y2 = scmodes.dataset.synthetic_mix(cyto, naive)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[7]:
    :END:

    Look at genes in the T cell/B cell mix where NPMLE has higher validation
    set log likelihood than NB.

    #+BEGIN_SRC ipython
      llik_diff = benchmark['cd8-cd19-mix']['npmle'] - benchmark['cd8-cd19-mix']['gamma']
      query = benchmark['cd8-cd19-mix'].loc[llik_diff[llik_diff > 0].sort_values(ascending=False).head(n=12).index].index
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[35]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cd8-cd19-mix-npmle-examples.png
      plt.clf()
      fig, ax = plt.subplots(3, 4)
      fig.set_size_inches(8, 6)
      for a, k in zip(ax.ravel(), query):
        a.hist(mix1.iloc[:,k], bins=np.arange(mix1.iloc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta l$={benchmark['cd8-cd19-mix']['npmle'].loc[k] - benchmark['cd8-cd19-mix']['gamma'].loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(gene_info.loc[mix1.columns[k], 'name'] if mix1.columns[k] in gene_info.index else mix1.columns[k])
      for a in ax:
        a[0].set_ylabel('Num cells')
      for a in ax.T:
        a[-1].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[17]:
    [[file:figure/deconvolution.org/cd8-cd19-mix-npmle-examples.png]]
    :END:

    Look at /CD74/ gene expression, stratified by known cell type.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cd74-example.png
      plt.clf()
      fig, ax = plt.subplots(1, 2, sharey=True)
      fig.set_size_inches(5, 2)
      for i, a in enumerate(ax):
        a.hist(mix1.loc[y1 == i,mix1.columns[query[0]]], bins=np.arange(mix1.loc[:,mix1.columns[query[0]]].max() + 1), color='k')
        a.set_title(['B cells', 'T cells'][i])
        a.set_xlabel('Number of molecules')
      ax[0].set_ylabel('Number of cells')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[41]:
    : Text(0, 0.5, 'Number of cells')
    [[file:figure/deconvolution.org/cd74-example.png]]
    :END:

    Look at genes in the Cytotoxic/naive T cell mix where NPMLE has higher
    validation set log likelihood than NB.'

    #+BEGIN_SRC ipython
      llik_diff = benchmark['cyto-naive-t-mix']['npmle'] - benchmark['cyto-naive-t-mix']['gamma']
      query = benchmark['cyto-naive-t-mix'].loc[llik_diff[llik_diff > 0].sort_values(ascending=False).head(n=12).index].index
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[42]:
    :END:

    Count how many genes this is the case for.

    #+BEGIN_SRC ipython
      benchmark['cyto-naive-t-mix'].loc[llik_diff > 0].shape[0]
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[23]:
    : 240
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cyto-naive-t-mix-npmle-examples.png
      plt.clf()
      fig, ax = plt.subplots(3, 4)
      fig.set_size_inches(8, 6)
      for a, k in zip(ax.ravel(), query):
        a.hist(mix2.loc[:,k], bins=np.arange(mix2.loc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta l$={benchmark['cyto-naive-t-mix']['npmle'].loc[k] - benchmark['cyto-naive-t-mix']['gamma'].loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(gene_info.loc[k, 'name'] if k in gene_info.index else k)
      for a in ax:
        a[0].set_ylabel('Num cells')
      for a in ax.T:
        a[-1].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[30]:
    [[file:figure/deconvolution.org/cyto-naive-t-mix-npmle-examples.png]]
    :END:

    /MALAT1/ ([[https://www.omim.org/entry/607924][Metastasis-associated lung
    adenocarcinoma transcript 1]]) is a lincRNA which appears to show tri-modal
    gene expression in this mixture. It is involved in T cell activation,
    through interaction with NF-κB
    ([[https://febs.onlinelibrary.wiley.com/doi/full/10.1002/1873-3468.12315][Zhao
    et al. 2016]]).

    Stratify /MALAT1/ gene expression by known cell type.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/MALAT1-example.png
      plt.clf()
      fig, ax = plt.subplots(1, 2, sharey=True)
      fig.set_size_inches(5, 2)
      for i, a in enumerate(ax):
        a.hist(mix2.loc[y2 == i,'ENSG00000251562'], bins=np.arange(mix2.loc[:,'ENSG00000251562'].max() + 1), color='k')
        a.set_title(['Naive T cells', 'Cytotoxic T cells'][i])
        a.set_xlabel('Number of molecules')
      ax[0].set_ylabel('Number of cells')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[43]:
    : Text(0, 0.5, 'Number of cells')
    [[file:figure/deconvolution.org/MALAT1-example.png]]
    :END:

** Heterogeneous cell populations
*** Run the benchmark

    #+NAME: heterogeneous-data
    #+BEGIN_SRC ipython :eval never
      data = {
        'pbmcs_68k': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/fresh_68k_pbmc_donor_a/filtered_matrices_mex/hg19', return_df=True),
        'cortex': lambda: scmodes.dataset.cortex('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/zeisel-2015/GSE60361_C1-3005-Expression.txt.gz', return_df=True)
      }
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[3]:
    :END:

    #+NAME: heterogeneous-benchmark-gpu
    #+BEGIN_SRC ipython :eval never
     <<imports>>
     import os
     <<heterogeneous-data>>
     tasks = ['pbmcs_68k', 'cortex']
     task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
     x = data[task]()
     res = scmodes.benchmark.evaluate_deconv_generalization(x.values, pool=None, test_size=0.1, random_state=0, methods=['gamma', 'point_gamma'])
     res.index = x.columns
     res.to_csv(f'/scratch/midway2/aksarkar/modes/deconv-generalization/{task}-gpu.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=gpu2 -a 0-1 --gres=gpu:1 --mem=16G --time=12:00:00 --job-name=benchmark --output=benchmark-gpu.out
      #!/bin/bash
      source activate scmodes
      python <<EOF
      <<heterogeneous-benchmark-gpu>>
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59696754

    #+NAME: heterogeneous-benchmark-cpu
    #+BEGIN_SRC ipython :eval never
     <<imports>>
     import os
     <<heterogeneous-data>>
     cpu_methods = ['unimodal', 'zief', 'npmle']
     tasks = [(d, c) for d in data for c in cpu_methods]
     dataset, method = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
     with mp.Pool() as pool:
       x = data[dataset]()
       res = scmodes.benchmark.evaluate_deconv_generalization(x.values, pool=pool, train_size=0.5, test_size=0.1, random_state=0, methods=[method])
       res.index = x.columns
       res.to_csv(f'/scratch/midway2/aksarkar/modes/deconv-generalization/{dataset}-{method}.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=broadwl -a 2 -n1 -c28 --exclusive --mem=32G --time=24:00:00 --job-name=benchmark --output=benchmark-cpu.out
      #!/bin/bash
      source activate scmodes
      python <<EOF
      <<heterogeneous-benchmark-cpu>>
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59818875

    Read the results.

    #+BEGIN_SRC ipython
      benchmark = {}
      for data in ('cortex', 'pbmcs_68k'):
        benchmark[data] = (
          pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-gpu.txt.gz', index_col=0, sep='\t')
          .merge(pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-unimodal.txt.gz', index_col=0, sep='\t'), left_index=True, right_index=True)
          .merge(pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-zief.txt.gz', index_col=0, sep='\t'), left_index=True, right_index=True)
          .merge(pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-npmle.txt.gz', index_col=0, sep='\t'), left_index=True, right_index=True))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[6]:
    :END:

    Plot the results.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/heterogeneous-benchmark.png
      fig, ax = plt.subplots(1, 2, sharey=True)
      fig.set_size_inches(5, 3)
      for a, k, t in zip(ax, sorted(benchmark.keys()), ['Mouse cortex', 'Human PBMCs']):
        a.boxplot(np.ma.masked_invalid((benchmark[f'{k}'].values - benchmark[f'{k}']['gamma'].values.reshape(-1, 1))[:,1:]).filled(-1e6),
                  widths=0.25, medianprops={'color': 'k'}, flierprops={'marker': '.', 'markersize': 4})
        a.set_xticklabels(['ZIG', 'Unimodal', 'ZIEF', 'NPMLE'], rotation=90)
        a.set_xlabel('Assumed latent dist')
        a.set_title(t)
      ax[0].set_ylabel('Diff val set log lik from Gamma')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[6]:
    [[file:figure/deconvolution.org/heterogeneous-benchmark.png]]
    :END:

    Zoom in on the relevant part of the plot.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/heterogeneous-benchmark-inset.png
      fig, ax = plt.subplots(1, 2)
      fig.set_size_inches(5, 3)
      for a, k, t in zip(ax, sorted(benchmark.keys()), ['Mouse cortex', 'Human PBMCs']):
        T = np.ma.masked_invalid((benchmark[f'{k}'].values - benchmark[f'{k}']['gamma'].values.reshape(-1, 1))[:,1:]).filled(-1e6)
        a.boxplot(T, widths=0.25, medianprops={'color': 'k'}, flierprops={'marker': '.', 'markersize': 4})
        a.axhline(y=0, ls=':', lw=1, c='k')
        a.set_xticklabels(['ZIG', 'Unimodal', 'ZIEF', 'NPMLE'], rotation=90)
        a.set_xlabel('Assumed latent dist')
        a.set_ylim(-20, 1.05 * T.max())
        a.set_title(t)
      ax[0].set_ylabel('Diff val set log lik from Gamma')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[7]:
    [[file:figure/deconvolution.org/heterogeneous-benchmark-inset.png]]
    :END:

*** Genes favoring more complex models

    Look at the genes where ZIG shows the most gain in validation set log
    likelihood.

    #+NAME: fix-cortex
    #+BEGIN_SRC ipython :eval never
      import scmodes
      work = scmodes.dataset.cortex('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/zeisel-2015/GSE60361_C1-3005-Expression.txt.gz', return_df=True)
      work.to_csv('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/zeisel-2015/zeisel-2015.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=broadwl --mem=16G
      #!/bin/bash
      source activate scmodes
      python <<EOF
      <<fix-cortex>>
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59827994

    #+BEGIN_SRC ipython
      cortex_counts = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/zeisel-2015/zeisel-2015.txt.gz', sep='\t', index_col=0)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[19]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cortex-zig-examples.png
      llik_diff = benchmark['cortex']['point_gamma'] - benchmark['cortex']['gamma']
      query = benchmark['cortex'].loc[llik_diff[llik_diff > 0].sort_values(ascending=False).head(n=12).index].index
      plt.clf()
      fig, ax = plt.subplots(4, 3)
      fig.set_size_inches(7, 5)
      for a, k in zip(ax.ravel(), query):
        a.hist(cortex_counts.loc[:,k], bins=np.arange(cortex_counts.loc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta l$={llik_diff.loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(k.upper())
      for y in range(ax.shape[0]):
        ax[y][0].set_ylabel('Num cells')
      for x in range(ax.shape[1]):
        ax[-1][x].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[14]:
    [[file:figure/deconvolution.org/cortex-zig-examples.png]]
    :END:

    Look at genes where unimodal shows greatest performance gain.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cortex-unimodal-examples.png
      llik_diff = benchmark['cortex']['unimodal'] - benchmark['cortex']['gamma']
      query = benchmark['cortex'].loc[llik_diff[llik_diff > 0].sort_values(ascending=False).head(n=12).index].index
      plt.clf()
      fig, ax = plt.subplots(4, 3)
      fig.set_size_inches(7, 5)
      for a, k in zip(ax.ravel(), query):
        a.hist(cortex_counts.loc[:,k], bins=np.arange(cortex_counts.loc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta l$={llik_diff.loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(k.upper())
      for y in range(ax.shape[0]):
        ax[y][0].set_ylabel('Num cells')
      for x in range(ax.shape[1]):
        ax[-1][x].set_xlabel('Num mols')
      fig.tight_layout()

    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[13]:
    [[file:figure/deconvolution.org/cortex-unimodal-examples.png]]
    :END:

    Show genes where NPMLE shows greatest performance gain.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cortex-npmle-examples.png
      llik_diff = benchmark['cortex']['npmle'] - benchmark['cortex']['gamma']
      query = benchmark['cortex'].loc[llik_diff[llik_diff > 0].sort_values(ascending=False).head(n=12).index].index
      plt.clf()
      fig, ax = plt.subplots(4, 3)
      fig.set_size_inches(7, 5)
      for a, k in zip(ax.ravel(), query):
        a.hist(cortex_counts.loc[:,k], bins=np.arange(cortex_counts.loc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta l$={llik_diff.loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(k.upper())
      for y in range(ax.shape[0]):
        ax[y][0].set_ylabel('Num cells')
      for x in range(ax.shape[1]):
        ax[-1][x].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[15]:
    [[file:figure/deconvolution.org/cortex-npmle-examples.png]]
    :END:

    - /GPM6A/ ([[https://www.ncbi.nlm.nih.gov/gene/234267][Glycoprotein m6a]])
      appears to be required for mouse brain develoment, and is expressed in
      specific brain regions
    - /SCN2A/ ([[https://www.ncbi.nlm.nih.gov/gene/110876][Sodium channel,
      voltage-gated, type II, alpha]]) is needed for propagating actions
      potentials in neurons

    Stratify the gene expression of these genes by inferred cell type.

    #+BEGIN_SRC sh :dir /project2/mstephens/aksarkar/projects/singlecell-ideas/data/zeisel-2015/
      curl -sLO "https://storage.googleapis.com/linnarsson-lab-www-blobs/blobs/cortex/expression_mRNA_17-Aug-2014.txt"
      gzip expression_mRNA_17-Aug-2014.txt
    #+END_SRC

    #+RESULTS:

    #+BEGIN_SRC ipython
      cortex_celltypes = (pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/zeisel-2015/expression_mRNA_17-Aug-2014.txt.gz', sep='\t', header=None, index_col=0, nrows=10)
                          .reset_index(drop=True)
                          .set_index(1))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[75]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cortex-gpm6a.png
      plt.clf()
      fig, ax = plt.subplots(3, 3)
      fig.set_size_inches(6, 6)
      for a, k in zip(ax.ravel(), set(cortex_celltypes.loc['level1class'])):
        x = cortex_counts.loc[(cortex_celltypes.loc['level1class'] == k).values, 'Gpm6a']
        a.hist(x, bins=np.arange(x.max() + 1), color='k')
        a.set_title(k)
      for a in ax:
        a[0].set_ylabel('Num cells')
      for a in ax.T:
        a[-1].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[78]:
    [[file:figure/deconvolution.org/cortex-gpm6a.png]]
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cortex-scn2a.png
      plt.clf()
      fig, ax = plt.subplots(3, 3)
      fig.set_size_inches(6, 6)
      for a, k in zip(ax.ravel(), set(cortex_celltypes.loc['level1class'])):
        x = cortex_counts.loc[(cortex_celltypes.loc['level1class'] == k).values, 'Scn2a1']
        a.hist(x, bins=np.arange(x.max() + 1), color='k')
        a.set_title(k)
      for a in ax:
        a[0].set_ylabel('Num cells')
      for a in ax.T:
        a[-1].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[84]:
    [[file:figure/deconvolution.org/cortex-scn2a.png]]
    :END:
