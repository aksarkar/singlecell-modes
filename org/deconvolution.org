#+TITLE: Comparison of expression deconvolution approaches
#+SETUPFILE: setup.org
#+OPTIONS: toc:2

* Introduction

  Suppose we have observations \(x_i \sim f(\theta_i), i = 1, \ldots, n\), and
  \(\theta_i \sim g(\cdot)\). /Distribution deconvolution/ is the problem of
  estimating \(g \in \mathcal{G}\) from \(x_1, \ldots, x_n\), assuming \(f\) is known
  ([[https://academic.oup.com/biomet/article/103/1/1/2390141][Efron
  2016]]).

  Recent work suggests that scRNA-seq data follows this generative model
  ([[http://dx.doi.org/10.1073/pnas.1721085115][Wang et al. 2018]]). Here, we
  investigate the trade-off between model complexity/flexibility and
  generalization for different choices of \(\mathcal{G}\) in real data.

* Setup

  #+BEGIN_SRC emacs-lisp :exports none
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(mem="16G",partition="mstephens",venv="scmodes") :dir /scratch/midway2/aksarkar/modes :exports none

  #+RESULTS:
  : Submitted batch job 59349678

  #+NAME: imports
  #+BEGIN_SRC ipython
    import functools as ft
    import multiprocessing as mp
    import numpy as np
    import pandas as pd
    import scipy.stats as st
    import scipy.special as sp
    import scmodes
    import sklearn.model_selection as skms

    import rpy2.robjects.packages
    import rpy2.robjects.pandas2ri
    import rpy2.robjects.numpy2ri

    rpy2.robjects.pandas2ri.activate()
    rpy2.robjects.numpy2ri.activate()

    ashr = rpy2.robjects.packages.importr('ashr')
    descend = rpy2.robjects.packages.importr('descend')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[1]:
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[2]:
  :END:

  #+BEGIN_SRC ipython
    import colorcet
    import matplotlib.pyplot as plt
    plt.rcParams['figure.facecolor'] = 'w'
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[3]:
  :END:

* Methods
** Distribution deconvolution

   The general form of distribution deconvolution for scRNA-seq is:

   \[ x_{ij} \sim \mathrm{Poisson}(\exp(\mathbf{z}_i' \mathbf{b}_j) \lambda_{ij}) \]

   \[ \lambda_{ij} \sim g_j(\cdot) \]

   where:

   - \(x_{ij}\) is the count of molecules of gene \(j\) in cell \(i\)
   - \(\mathbf{z}_i\) is a \(q\)-vector of covariates for cell \(i\)
   - \(\mathbf{b}_j\) is a \(q\)-vector of confounding effects on gene \(j\)
   - \(\lambda_{ij}\) is proportional to the relative abundance of gene \(j\)
     in cell \(i\)

   The primary inference goal is to recover \(g_j\). A secondary goal could be
   to recover \(\lambda_{ij}\). We can trade off flexibility and complexity of
   \(g_j\) for ease of implementation and speed.

   1. *Point mass:* \(g_j = \delta_\mu\). We mention it for completeness.
   2. *Gamma:* \(g_j = \mathrm{Gamma}(\cdot)\). This leads to the negative
      binomial marginal likelihood, and can be motivated by the empirical
      observation that the counts are overdispersed.
   3. *Point-Gamma:* \(g_j = \pi_j \delta_0(\cdot) + (1 - \pi_j)
      \mathrm{Gamma}(\cdot)\). This leads to the zero-inflated negative
      binomial marginal likelihood, which is still analytic and therefore
      computationally favorable. The inclusion of the point mass can be
      motivated by theory suggesting a biological mechanism for bimodal gene
      expression ([[http://dx.doi.org/10.1126/science.1216379][Munsky et
      al. 2013]], [[http://dx.doi.org/10.1186/gb-2013-14-1-r7][Kim and Marioni
      2013]]).
   4. *Unimodal:* \(g_j\) is some unimodal distribution over non-negative
      reals. In practice, we represent this family of distribution as \(g_j =
      \sum_k \pi_k \mathrm{Uniform}(\cdot; \lambda_0, a_{jk})\), where \(k = 1,
      \ldots, K\) are sufficiently many and \(\lambda_0\) is the mode
      ([[http://dx.doi.org/10.1093/biostatistics/kxw041][Stephens 2016]]).
   5. *Zero-inflated exponential family:* \(g_j = \exp(\mathbf{Q}\alpha -
      \phi(\alpha))\), where \(\mathbf{Q}\) is a
      [[https://en.wikipedia.org/wiki/B-spline][B spline spline basis matrix]]
      for a [[https://en.wikipedia.org/wiki/Cubic_Hermite_spline][natural cubic
      spline]]
      ([[https://www.rdocumentation.org/packages/splines/topics/ns][~ns~
      function]];
      [[https://academic.oup.com/biomet/article/103/1/1/2390141][Efron
      2016]]). The key idea of the method is use spline regression to find the
      sufficient statistic and natural parameters which maximizes the penalized
      likelihood of the observed data. The method has been extended to include
      a point mass on zero ([[http://dx.doi.org/10.1073/pnas.1721085115][Wang
      et al. 2018]]).
   6. *Nonparametric:* \(g_j\) is some distribution over non-negative reals
      ([[https://projecteuclid.org/euclid.aoms/1177728066][Kiefer and Wolfowitz
      1956]]). In practice, we discretize the representation
      ([[https://amstat.tandfonline.com/doi/abs/10.1080/01621459.2013.869224][Koenker
      and Mizera 2014]]). In full detail, we use the representation \(g_j =
      \sum_k \pi_k \mathrm{Uniform}(\cdot; ak, a(k + 1))\), where \(a\) is a
      fixed step size, which allows us to re-use the ~ash~ implementation.

   In order to evaluate methods on their ability to estimate \(g_j\), we hold
   out a validation set, and compute the validation set log likelihood. Based
   on our preliminary experiments, we compare all methods against Gamma.

   The benchmarking code is implemented in the Python package
   [[https://github.com/aksarkar/scmodes][scmodes]].

** Benchmarking data

   As examples of homogeneous cell populations, we use:

   1. Sorted immune cells sequenced on the 10X platform
      ([[https://www.nature.com/articles/ncomms14049][Zheng et al. 2017]])

   2. iPSCs derived from Yoruba LCLs, sequenced on the Fluidigm C1 platform
      ([[https://www.biorxiv.org/content/early/2018/09/23/424192][Sarkar et
      al. 2018]])

   We use the homogeneous cells populations to generate synthetic mixtures with
   known cell type labels.

   As examples of heterogeneous cell populations, we use:

   1. Fresh PBMCs sequenced on the 10X platform
      ([[https://www.nature.com/articles/ncomms14049][Zheng et al. 2017]])

   2. Mouse neuron cells sequenced on the Fluidigm C1 platform
      ([[https://science.sciencemag.org/content/347/6226/1138.full][Zeisel et
      al. 2015]])

* Results
** Homogeneous cell populations
*** Example
    :PROPERTIES:
    :CUSTOM_ID: examples
    :END:

    As an example, use the highest expressed genes in 10K sorted CD8+ cytotoxic
    T cells [[https://www.nature.com/articles/ncomms14049][Zheng et al. 2017]].

    #+BEGIN_SRC ipython
      x = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19')
      xj = pd.Series(x[:,x.mean(axis=0).argmax()])
      size_factor = pd.Series(x.sum(axis=1))
      lam = xj / size_factor
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[4]:
    :END:

    Fit unimodal distribution.

    #+BEGIN_SRC ipython :async t
      unimix_res = ashr.ash_workhorse(
        pd.Series(np.zeros(x.shape[0])),
        1,
        lik=ashr.lik_pois(y=xj, scale=size_factor, link='identity'),
        outputlevel='fitted_g',
        mixsd=pd.Series(np.geomspace(lam.min(), lam.max(), 25)),
        mode=pd.Series([lam.min(), lam.max()]))
      unimix_cdf = ashr.cdf_ash(unimix_res, np.linspace(lam.min(), lam.max(), 1000))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[5]:
    :END:

    Fit NPMLE.

    #+BEGIN_SRC ipython :async t
      K = 200
      grid = np.linspace(lam.min(), lam.max(), K + 1)
      npmle_res = ashr.ash_workhorse(
        pd.Series(np.zeros(x.shape[0])),
        1,
        outputlevel='fitted_g',
        lik=ashr.lik_pois(y=xj, scale=size_factor, link='identity'),
        g=ashr.unimix(pd.Series(np.ones(K) / K), pd.Series(grid[:-1]), pd.Series(grid[1:])))
      npmle_cdf = ashr.cdf_ash(npmle_res, np.linspace(lam.min(), lam.max(), 1000))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[15]:
    :END:

    Fit DESCEND.

    #+BEGIN_SRC ipython
      descend_res = descend.deconvSingle(xj, scaling_consts=size_factor, verbose=False)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[7]:
    :END:

    Fit NB/ZINB.

    #+BEGIN_SRC ipython :eval never :noweb tangle :tangle /project2/mstephens/aksarkar/projects/singlecell-modes/code/fit-nb.py
      import numpy as np
      import pandas as pd
      import scipy.io
      import scmodes
      import scqtl

      x = scmodes.read10x(prefix='/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/')
      size_factor = x.sum(axis=1).reshape(-1, 1)
      onehot = np.ones((x.shape[0], 1))
      design = np.zeros((x.shape[0], 1))
      init = scqtl.tf.fit(
        umi=x.astype(np.float32),
        onehot=onehot.astype(np.float32),
        design=design.astype(np.float32),
        size_factor=size_factor.astype(np.float32),
        learning_rate=1e-3,
        max_epochs=30000,
        verbose=True)
      pd.DataFrame(init[0]).to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-nb-log-mu.txt.gz', compression='gzip', sep='\t')
      pd.DataFrame(init[1]).to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-nb-log-phi.txt.gz', compression='gzip', sep='\t')
      log_mu, log_phi, logodds, nb_llik, zinb_llik = scqtl.tf.fit(
        umi=x.astype(np.float32),
        onehot=onehot.astype(np.float32),
        design=design.astype(np.float32),
        size_factor=size_factor.astype(np.float32),
        learning_rate=1e-3,
        max_epochs=30000,
        warm_start=init[:3],
        verbose=True)
      pd.DataFrame(log_mu).to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-log-mu.txt.gz', compression='gzip', sep='\t')
      pd.DataFrame(log_phi).to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-log-phi.txt.gz', compression='gzip', sep='\t')
      pd.DataFrame(logodds).to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-logodds.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=gpu2 --gres=gpu:1 --mem=16G --time=60:00 --job-name=fit-nb
      #!/bin/bash
      source activate scmodes
      python /project2/mstephens/aksarkar/projects/singlecell-modes/code/fit-nb.py
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 58803475

    #+BEGIN_SRC ipython
      j = str(x.mean(axis=0).argmax())
      nb_log_mu = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-nb-log-mu.txt.gz', sep='\t')
      nb_log_phi = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-nb-log-phi.txt.gz', sep='\t')
      # Gamma (Use MATLAB and MATHEMATICA (b=theta=scale, a=alpha=shape) definition)
      # https://github.com/scipy/scipy/blob/v1.2.1/scipy/stats/_continuous_distns.py#L2479
      gamma_cdf = st.gamma(a=np.exp(-nb_log_phi[j]), scale=np.exp(nb_log_mu[j] + nb_log_phi[j])).cdf(np.linspace(lam.min(), lam.max(), 1000))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[8]:
    :END:

    #+BEGIN_SRC ipython
      zinb_log_mu = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-log-mu.txt.gz', sep='\t')
      zinb_log_phi = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-log-phi.txt.gz', sep='\t')
      zinb_logodds = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-example/zheng-cd8-zinb-logodds.txt.gz', sep='\t')
      point_gamma_cdf = st.gamma(a=np.exp(-zinb_log_phi[j]), scale=np.exp(zinb_log_mu[j] + zinb_log_phi[j])).cdf(np.linspace(lam.min(), lam.max(), 1000))
      point_gamma_cdf *= sp.expit(-zinb_logodds[j].values)
      point_gamma_cdf += sp.expit(zinb_logodds[j].values)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[9]:
    :END:

    Plot the observed counts and deconvolved distributions.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/deconv-example.png
      cm = plt.get_cmap('Dark2').colors
      fig, ax = plt.subplots(2, 1)
      h = ax[0].hist(xj, bins=np.arange(xj.max() + 1), color='k')
      ax[0].set_xlabel('Molecule count')
      ax[0].set_ylabel('Number of cells')

      ax[1].plot(np.linspace(lam.min(), lam.max(), 1000), gamma_cdf, color=cm[0], lw=1, label='Gamma')
      ax[1].plot(np.linspace(lam.min(), lam.max(), 1000), point_gamma_cdf, color=cm[1], lw=1, label='Point-Gamma')
      ax[1].plot(np.array(unimix_cdf.rx2('x')),
                 np.array(unimix_cdf.rx2('y')).ravel(), c=cm[2], lw=1, label='Unimodal')
      F = np.cumsum(np.array(descend_res.slots['density.points'])[:,1])
      ax[1].plot(np.array(descend_res.slots['density.points'])[:,0],
                 F / F.max(), c=cm[3], lw=1, label='ZIEF')
      ax[1].plot(np.array(npmle_cdf.rx2('x')),
                 np.array(npmle_cdf.rx2('y')).ravel(), c=cm[4], lw=1, label='NPMLE')
      ax[1].set_xlabel('Latent gene expression')
      ax[1].set_ylabel('CDF')

      ax[1].legend(frameon=False)

      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[16]:
    [[file:figure/deconvolution.org/deconv-example.png]]
    :END:

    Print out the histogram for inspection.

    #+BEGIN_SRC ipython
      np.vstack((h[1][:-1], h[0])).T
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[52]:
    #+BEGIN_EXAMPLE
      array([[  0.,   0.],
      [  1.,   1.],
      [  2.,   1.],
      [  3.,   0.],
      [  4.,   0.],
      [  5.,   0.],
      [  6.,   1.],
      [  7.,   0.],
      [  8.,   1.],
      [  9.,   5.],
      [ 10.,   8.],
      [ 11.,   4.],
      [ 12.,   9.],
      [ 13.,   9.],
      [ 14.,   8.],
      [ 15.,  20.],
      [ 16.,  17.],
      [ 17.,  24.],
      [ 18.,  31.],
      [ 19.,  44.],
      [ 20.,  39.],
      [ 21.,  41.],
      [ 22.,  46.],
      [ 23.,  72.],
      [ 24.,  68.],
      [ 25.,  74.],
      [ 26.,  74.],
      [ 27.,  86.],
      [ 28.,  94.],
      [ 29., 114.],
      [ 30.,  96.],
      [ 31., 102.],
      [ 32., 120.],
      [ 33., 132.],
      [ 34., 161.],
      [ 35., 138.],
      [ 36., 159.],
      [ 37., 197.],
      [ 38., 186.],
      [ 39., 210.],
      [ 40., 232.],
      [ 41., 244.],
      [ 42., 284.],
      [ 43., 309.],
      [ 44., 321.],
      [ 45., 332.],
      [ 46., 342.],
      [ 47., 371.],
      [ 48., 349.],
      [ 49., 356.],
      [ 50., 317.],
      [ 51., 343.],
      [ 52., 347.],
      [ 53., 342.],
      [ 54., 308.],
      [ 55., 294.],
      [ 56., 274.],
      [ 57., 272.],
      [ 58., 241.],
      [ 59., 219.],
      [ 60., 191.],
      [ 61., 164.],
      [ 62., 145.],
      [ 63., 144.],
      [ 64., 120.],
      [ 65., 121.],
      [ 66., 100.],
      [ 67.,  95.],
      [ 68.,  69.],
      [ 69.,  62.],
      [ 70.,  53.],
      [ 71.,  47.],
      [ 72.,  52.],
      [ 73.,  32.],
      [ 74.,  35.],
      [ 75.,  36.],
      [ 76.,  30.],
      [ 77.,  28.],
      [ 78.,  20.],
      [ 79.,  27.],
      [ 80.,  26.],
      [ 81.,  21.],
      [ 82.,  12.],
      [ 83.,  12.],
      [ 84.,   9.],
      [ 85.,   7.],
      [ 86.,  12.],
      [ 87.,   8.],
      [ 88.,   9.],
      [ 89.,   6.],
      [ 90.,   4.],
      [ 91.,   5.],
      [ 92.,   2.],
      [ 93.,   2.],
      [ 94.,   2.],
      [ 95.,   3.],
      [ 96.,   1.],
      [ 97.,   2.],
      [ 98.,   2.],
      [ 99.,   0.],
      [100.,   0.],
      [101.,   0.],
      [102.,   1.],
      [103.,   1.],
      [104.,   0.],
      [105.,   0.],
      [106.,   2.]])
    #+END_EXAMPLE
    :END:

    Look at what is going on with NPMLE.

    #+BEGIN_SRC ipython
      res0 = ashr.ash_workhorse(
        pd.Series(np.zeros(x.shape[0])),
        1,
        outputlevel=pd.Series(['fitted_g', 'loglik']),
        lik=ashr.lik_pois(y=xj, scale=size_factor, link='identity'),
        g=ashr.unimix(pd.Series(np.ones(100) / 100), pd.Series(grid[:-1]), pd.Series(grid[1:])))
      res1 = ashr.ash_workhorse(
        pd.Series(np.zeros(x.shape[0])),
        1,
        outputlevel=pd.Series(['fitted_g', 'loglik']),
        lik=ashr.lik_pois(y=xj, scale=size_factor, link='identity'),
        g=ashr.unimix(pd.Series(np.ones(200) / 200), pd.Series(grid[:-1]), pd.Series(grid[1:])))
    #+END_SRC

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/npmle-example.png
      plt.clf()
      plt.gcf().set_size_inches(4, 2)
      grid = np.linspace(lam.min(), lam.max(), 1000)
      plt.plot(grid, np.array(ashr.cdf_ash(res0, grid)[1]).ravel(), label='NPMLE (100 components)', lw=1, c='k')
      plt.plot(grid, np.array(ashr.cdf_ash(res1, grid)[1]).ravel(), label='NPMLE (200 components)', lw=2, ls=':', c='r')
      plt.legend(frameon=False)
      plt.xlabel('Latent gene expression')
      plt.ylabel('CDF')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[40]:
    : Text(0, 0.5, 'CDF')
    [[file:figure/deconvolution.org/npmle-example.png]]
    :END:

    #+BEGIN_SRC ipython
      np.array(res0.rx2('loglik')) - np.array(res1.rx2('loglik'))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[41]:
    : array([0.])
    :END:

*** Run the benchmark
    :PROPERTIES:
    :CUSTOM_ID: homogeneous-results
    :END:

    Run the benchmark.

    #+NAME: run-homogeneous-benchmark-cpu
    #+BEGIN_SRC ipython :eval never
      <<imports>>
      import os
      data = {
        'cytotoxic_t': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True),
        'b_cells': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True),
        'ipsc': lambda: scmodes.dataset.ipsc('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/', n=100, return_df=True),
      }
      cpu_methods = ['unimodal', 'zief', 'npmle']
      tasks = [(d, c) for d in data for c in cpu_methods]
      task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
      with mp.Pool(maxtasksperchild=20) as pool:
        # Important: this needs to be done after initializing the pool to avoid
        # memory duplication
        x = data[task[0]]()
        res = scmodes.benchmark.evaluate_deconv_generalization(x.values, pool=pool, test_size=0.1, random_state=0, methods=[task[1]])
        res.index = x.columns
        res.to_csv(f'/scratch/midway2/aksarkar/modes/{task[0]}-{task[1]}.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=broadwl --mem=32G -a 6-8 -n1 -c28 --exclusive --time=12:00:00 --job-name=benchmark --output=benchmark-cpu.out
      #!/bin/bash
      source activate scmodes
      python <<EOF
      <<run-homogeneous-benchmark-cpu>>
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59511459

    #+NAME: run-homogeneous-benchmark-gpu
    #+BEGIN_SRC ipython :eval never
      <<imports>>
      import os
      data = {
        'cytotoxic_t': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True),
        'b_cells': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True),
        # Important: run the benchmark on all genes
        'ipsc': lambda: scmodes.dataset.ipsc('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/', return_df=True),
      }
      tasks = list(data.keys())
      task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
      x = data[task]()
      res = scmodes.benchmark.evaluate_deconv_generalization(x.values, pool=None, test_size=0.1, random_state=0, methods=['gamma', 'point_gamma'])
      res.index = x.columns
      res.to_csv(f'/scratch/midway2/aksarkar/modes/deconv-generalization/{task}-gpu.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=gpu2 --gres=gpu:1 -a 2 --mem=16G --time=12:00:00 --job-name=benchmark --output=benchmark-gpu.out
      #!/bin/bash
      module load cuda/9.0
      source activate scmodes
      python <<EOF
      <<run-homogeneous-benchmark-gpu>>
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59503539

    Read the results.

    #+BEGIN_SRC ipython
      benchmark = {}
      for data in ('cd8_cytotoxic_t_cells', 'cd19_b_cells'):
        benchmark[data] = pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}.txt.gz', sep='\t', index_col=0)
      benchmark['ipsc'] = (
        pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/ipsc-gpu.txt.gz', index_col=0, sep='\t')
        .merge(pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/ipsc-unimix.txt.gz', index_col=0, sep='\t'), on='gene')
        .merge(pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/ipsc-descend.txt.gz', sep='\t'), on='gene')
        .merge(pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/ipsc-npmle.txt.gz', index_col=0, sep='\t'), on='gene')
        .merge(pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/ipsc-saturated.txt.gz', index_col=0, sep='\t'), on='gene')
        .set_index('gene'))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[57]:
    :END:

    Plot the generalization performance of each method.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/homogeneous-benchmark.png
      fig, ax = plt.subplots(1, 3)
      fig.set_size_inches(7, 3)
      for i, k in enumerate(sorted(benchmark.keys())):
        ax[i].boxplot((benchmark[f'{k}'].values - benchmark[f'{k}']['nb'].values.reshape(-1, 1))[:,1:-1],
                      widths=0.25, medianprops={'color': 'k'}, flierprops={'marker': '.', 'markersize': 4})
        ax[i].set_xticklabels(['ZINB', 'Unimodal', 'ZIEF', 'NPMLE'], rotation=90)
        ax[i].set_xlabel('Assumed latent dist')
        ax[i].set_title(k)
      ax[0].set_ylabel('Diff val set log lik from NB')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[79]:
    [[file:figure/deconvolution.org/homogeneous-benchmark.png]]
    :END:

    Zoom in on the relevant part of the plot.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/homogeneous-benchmark-inset.png
      fig, ax = plt.subplots(1, 3)
      fig.set_size_inches(7, 3)
      for i, k in enumerate(sorted(benchmark.keys())):
        T = (benchmark[f'{k}'].values - benchmark[f'{k}']['nb'].values.reshape(-1, 1))[:,1:-1]
        ax[i].boxplot(T, widths=0.25, medianprops={'color': 'k'}, flierprops={'marker': '.', 'markersize': 4})
        ax[i].axhline(y=0, ls=':', lw=1, c='k')
        ax[i].set_xticklabels(['ZINB', 'Unimodal', 'ZIEF', 'NPMLE'], rotation=90)
        ax[i].set_xlabel('Assumed latent dist')
        ax[i].set_ylim(-20, 1.05 * T.max())
        ax[i].set_title(k)
      ax[0].set_ylabel('Diff val set log lik from NB')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[81]:
    [[file:figure/deconvolution.org/homogeneous-benchmark-inset.png]]
    :END:

    The results suggest that NB (assuming Gamma-distributed latent gene
    expression) is adequate to accurately estimate \(g\) from the data.

    Of note, ~ash~ is >10\(\times\) slower than ~descend~, and ~descend~ is
    faster on small data sets than GPU-based methods. 

*** Investigate ZINB vs. NB in high-depth data
    :PROPERTIES:
    :CUSTOM_ID: bimodal-example-ipsc
    :END:

    Try to find a case in the full iPSC data where ZINB is required, by
    performing likelihood ratio tests against NB. Use Bonferroni correction to
    control FWER.

    #+BEGIN_SRC ipython
     ipsc_res = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/ipsc-gpu.txt.gz', index_col=0, sep='\t')
     lrt = st.chi2(1).sf(-2 * (ipsc_res['nb'] - ipsc_res['zinb']))
     ipsc_res[lrt < .05 / lrt.shape[0]]
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[13]:
    #+BEGIN_EXAMPLE
      nb         zinb
      gene
      ENSG00000112530 -2017.717750 -1987.894352
      ENSG00000129824 -1803.651932 -1789.106410
    #+END_EXAMPLE
    :END:

    #+BEGIN_SRC ipython :async t
     ipsc_counts = ipsc(query=list(ipsc_res[lrt < .05 / lrt.shape[0]].index), return_df=True)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[16]:
    :END:

    #+NAME: read-gene-info
    #+BEGIN_SRC ipython
     gene_info = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-genes.txt.gz', sep='\t', index_col=0)
    #+END_SRC

    #+RESULTS: read-gene-info
    :RESULTS:
    # Out[56]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/ipsc-zinb.png
     plt.clf()
     fig, ax = plt.subplots(1, 2)
     fig.set_size_inches(6, 3)
     for a, k in zip(ax, ipsc_counts):
       h = a.hist(ipsc_counts[k], bins=np.arange(ipsc_counts[k].max() + 1), color='k')
       a.set_title(gene_info.loc[k, 'name'])
       a.set_xlabel('Number of molecules')
       a.set_ylabel('Number of cells')
     fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[89]:
    [[file:figure/deconvolution.org/ipsc-zinb.png]]
    :END:

    Print out the histogram for /RPS4Y1/ for inspection.

    #+BEGIN_SRC ipython
     np.vstack((h[1][:-1], h[0])).T
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[91]:
    #+BEGIN_EXAMPLE
      array([[  0., 803.],
      [  1., 309.],
      [  2., 435.],
      [  3., 407.],
      [  4., 383.],
      [  5., 323.],
      [  6., 323.],
      [  7., 239.],
      [  8., 163.],
      [  9., 166.],
      [ 10., 132.],
      [ 11.,  98.],
      [ 12.,  97.],
      [ 13., 106.],
      [ 14.,  95.],
      [ 15.,  95.],
      [ 16.,  94.],
      [ 17., 109.],
      [ 18.,  92.],
      [ 19.,  89.],
      [ 20.,  87.],
      [ 21.,  83.],
      [ 22., 100.],
      [ 23.,  75.],
      [ 24.,  71.],
      [ 25.,  60.],
      [ 26.,  61.],
      [ 27.,  60.],
      [ 28.,  60.],
      [ 29.,  34.],
      [ 30.,  50.],
      [ 31.,  41.],
      [ 32.,  34.],
      [ 33.,  38.],
      [ 34.,  28.],
      [ 35.,  23.],
      [ 36.,  19.],
      [ 37.,  18.],
      [ 38.,  11.],
      [ 39.,   7.],
      [ 40.,  17.],
      [ 41.,   8.],
      [ 42.,  12.],
      [ 43.,   7.],
      [ 44.,   4.],
      [ 45.,  11.],
      [ 46.,   4.],
      [ 47.,   2.],
      [ 48.,   1.],
      [ 49.,   3.],
      [ 50.,   1.],
      [ 51.,   1.],
      [ 52.,   2.],
      [ 53.,   1.],
      [ 54.,   1.],
      [ 55.,   1.],
      [ 56.,   2.],
      [ 57.,   0.],
      [ 58.,   0.],
      [ 59.,   0.],
      [ 60.,   0.],
      [ 61.,   0.],
      [ 62.,   0.],
      [ 63.,   0.],
      [ 64.,   0.],
      [ 65.,   1.]])
    #+END_EXAMPLE
    :END:

    /PACRG/ ([[https://www.omim.org/entry/608427][Parkin coregulated gene]])
    shares a promoter with /PKRG/ (/PARK2/;
    [[https://www.omim.org/entry/602544?search=park2&highlight=park2][Parkin]]). PARKIN
    is involved in a [[https://www.pnas.org/content/115/2/E180][signaling
    pathway for mitochondria damage]], and mitochrondrial damage appears to be
    relevant to neurodegenerative disease etiology
    ([[https://www.ncbi.nlm.nih.gov/pubmed/29414602][Alzheimer's disease]] and
    [[https://www.pnas.org/content/115/2/E180][Parkinson's disease]]).
    Mitochrondrial damage could explain the bimodal distribution of /PACRG/ in
    the iPSC data: the reprogramming protocol could induce oxidative stress on
    some of the cells, resulting in damage.

    /RPS4Y1/ ([[https://www.omim.org/entry/470000][Ribosomal protein S4,
    Y-linked]]) is on the Y chromosome, and therefore we should expect it to
    only be expressed in males. The homologous gene on the X chromosome
    ([[https://www.omim.org/entry/312760][/RPS4X/]]) has a different coding
    sequence. Naively, sex-linkage should explain why this gene exhibits bimodal
    gene expression.

    #+BEGIN_SRC sh :dir /project2/mstephens/aksarkar/projects/singlecell-modes/data/
     curl -OL 'http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/working/20130606_sample_info/20130606_sample_info.txt'
    #+END_SRC

    #+RESULTS:

    #+BEGIN_SRC ipython :async t
     donor_info = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/20130606_sample_info.txt', sep='\t')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[64]:
    :END:

    Count how many cells come from females.

    #+BEGIN_SRC ipython
     prefix = '/project2/mstephens/aksarkar/projects/singlecell-qtl/data/'
     annotations = pd.read_csv(f'{prefix}/scqtl-annotation.txt', sep='\t')
     keep_samples = pd.read_csv(f'{prefix}/quality-single-cells.txt', sep='\t', index_col=0, header=None)
     annotations = annotations.loc[keep_samples.values.ravel()]
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[17]:
    :END:

    #+BEGIN_SRC ipython
     annotations.merge(donor_info, left_on='chip_id', right_on='Sample')['Gender'].value_counts()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[100]:
    #+BEGIN_EXAMPLE
      female    3109
      male      2369
      Name: Gender, dtype: int64
    #+END_EXAMPLE
    :END:

    Look at the full benchmark results for NB vs. ZINB (only the GPU
    implementation is suitable for this).

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/homogeneous-nb-zinb-benchmark.png
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     h = plt.hist(ipsc_res['zinb'] - ipsc_res['nb'], color='k', bins=np.arange(-10, 40, 2))
     plt.xlabel('Diff val set log lik from NB')
     _ = plt.ylabel('Number of genes')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[135]:
    [[file:figure/deconvolution.org/homogeneous-nb-zinb-benchmark.png]]
    :END:

    Print the histogram for inspection.

    #+BEGIN_SRC ipython
     np.vstack((h[1][:-1], h[0])).T.astype(int)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[137]:
    #+BEGIN_EXAMPLE
      array([[ -10,    0],
      [  -8,    0],
      [  -6,    0],
      [  -4,    0],
      [  -2, 4977],
      [   0, 4973],
      [   2,    2],
      [   4,    3],
      [   6,    0],
      [   8,    0],
      [  10,    0],
      [  12,    0],
      [  14,    1],
      [  16,    0],
      [  18,    0],
      [  20,    0],
      [  22,    0],
      [  24,    0],
      [  26,    0],
      [  28,    1],
      [  30,    0],
      [  32,    0],
      [  34,    0],
      [  36,    0]])
    #+END_EXAMPLE
    :END:

    Look at the fitted ZINB distribution per-individual for this gene.

    #+BEGIN_SRC ipython
     ipsc_log_mu = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz', sep=' ', index_col=0)
     ipsc_log_phi = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz', sep=' ', index_col=0)
     ipsc_logodds = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz', sep=' ', index_col=0)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[10]:
    :END:

    #+BEGIN_SRC ipython
     def point_gamma_cdf(grid, log_mu, log_phi, logodds):
       res = st.gamma(a=np.exp(-log_phi), scale=np.exp(log_mu + log_phi)).cdf(grid)
       res *= sp.expit(-logodds)
       res += sp.expit(logodds)
       return res

     lam = ipsc_counts.values / annotations['mol_hs'].values.reshape(-1, 1)
     grid = np.linspace(lam.min(), lam.max(), 1000)
     cdfs = np.array([[point_gamma_cdf(grid,
                                       ipsc_log_mu.loc[j, k],
                                       ipsc_log_phi.loc[j, k],
                                       ipsc_logodds.loc[j, k])
                       for k in ipsc_log_mu]
                      for j in ipsc_counts.columns
                      if j != list(ipsc_log_mu.columns).index('NA18498')])
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[50]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/ipsc-point-gamma-cdf-pacrg.png
     plt.clf()
     fig, ax = plt.subplots(2, 1, sharex=True)
     fig.set_size_inches(6, 4)
     for a, F, k in zip(ax, cdfs, ipsc_counts.columns):
       for f in F:
         a.set_xlim(0, 2e-4)
         a.set_xticks(np.linspace(0, 2e-4, 3))
         a.plot(grid, f, c='k', lw=1, alpha=0.2)
       a.set_title(gene_info.loc[k, 'name'])
       a.set_ylabel('CDF')
     ax[-1].set_xlabel('Latent gene expression')
     fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[63]:
    [[file:figure/deconvolution.org/ipsc-point-gamma-cdf-pacrg.png]]
    :END:

    Plot the estimated /RPS4Y1/ latent gene expression, stratified by donor sex.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/ipsc-point-gamma-cdf-rps4y1.png
     colors = {k: 'r' if v == 'male' else 'b' for k, v in
               donor_info.set_index('Sample')
               .filter(items=list(ipsc_log_mu.columns), axis=0)
               ['Gender']
               .iteritems()}
     plt.clf()
     plt.gcf().set_size_inches(3, 2)
     for f, k in zip(cdfs[1], ipsc_log_mu.columns):
       plt.xlim(0, 2e-4)
       plt.xticks(np.linspace(0, 2e-4, 3))
       plt.plot(grid, f, lw=1, alpha=0.2, c=colors.get(k, 'k'))
       dummy = [plt.Line2D([0], [0], c='r'), plt.Line2D([0], [0], c='b')]
       plt.legend(dummy, ['Male', 'Female'], frameon=False)
       plt.title('RPS4Y1')
       plt.ylabel('CDF')
       plt.xlabel('Latent gene expression')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[99]:
    [[file:figure/deconvolution.org/ipsc-point-gamma-cdf-rps4y1.png]]
    :END:

*** Investigate genes with support for more complex models

    In B cells, several genes are better fit by DESCEND than other methods.

    #+BEGIN_SRC ipython
      b_cells = read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[146]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/b-cell-descend-examples.png
      query = benchmark['cd19_b_cells'][benchmark['cd19_b_cells']['descend'] > benchmark['cd19_b_cells']['nb']].index
      plt.clf()
      fig, ax = plt.subplots(6, 6, sharey=True, sharex=True)
      fig.set_size_inches(9, 9)
      for a, k in zip(ax.ravel(), query):
        a.hist(b_cells.iloc[:,k], bins=np.arange(b_cells.iloc[:,k].max() + 1), color='k')
        a.text(x=.9, y=.9,
               s=f"$\Delta L$={benchmark['cd19_b_cells']['descend'].loc[k] - benchmark['cd19_b_cells']['nb'].loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(gene_info.loc[b_cells.columns[k], 'name'] if b_cells.columns[k] in gene_info.index else b_cells.columns[k])
      for y in range(ax.shape[0]):
        ax[y][0].set_ylabel('Number of cells')
      for x in range(ax.shape[1]):
        ax[-1][x].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[179]:
    [[file:figure/deconvolution.org/b-cell-descend-examples.png]]
    :END:

    For comparison, consider the gene with the largest difference in validation
    set log likelihood. Deconvolve its gene expression assuming \(g_j =
    \delta_\mu(\cdot)\), using the fact:

    \[ \textstyle\sum_i x_i \sim \mathrm{Poisson}\left(\textstyle\sum_i R_i \mu\right) \]

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/b-cell-descend-pois.example.png
      diff = benchmark['cd19_b_cells']['descend'] - benchmark['cd19_b_cells']['nb']
      plt.clf()
      fig, ax = plt.subplots(1, 2, sharey=True)
      fig.set_size_inches(5, 2)
      np.random.seed(1)
      x = b_cells.iloc[:,diff.idxmax()]
      scale = b_cells.sum(axis=1)
      mu = x.sum() / scale.sum()
      y = np.random.poisson(lam=scale * mu)
      ax[0].hist(y, bins=np.arange(y.max() + 1), color='k')
      ax[0].set_title('Point mass')
      ax[1].hist(x, bins=np.arange(x.max() + 1), color='k')
      ax[1].set_title('ZIEF')
      ax[0].set_ylabel('Number of cells')
      for a in ax:
        a.set_xlabel('Molecule count')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[174]:
    [[file:figure/deconvolution.org/b-cell-descend-pois.example.png]]
    :END:

    In iPSC, several genes appear to be better fit by mixture of uniforms than
    other methods.

    #+BEGIN_SRC ipython :async t
      ipsc_counts = ipsc(n=100, return_df=True)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[175]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/ipsc-unimix-examples.png
      query = benchmark['ipsc'][benchmark['ipsc']['unimix'] > benchmark['ipsc']['nb']].index
      plt.clf()
      fig, ax = plt.subplots(2, 3)
      fig.set_size_inches(6, 4)
      for a, k in zip(ax.ravel(), query):
        h = a.hist(ipsc_counts.loc[:,k], bins=np.arange(ipsc_counts.loc[:,k].max() + 1), color='k')
        a.text(x=.9, y=.9,
               s=f"$\Delta L$={benchmark['ipsc']['unimix'].loc[k] - benchmark['ipsc']['nb'].loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(gene_info.loc[k, 'name'])
      for y in range(ax.shape[0]):
        ax[y][0].set_ylabel('Number of cells')
      for x in range(ax.shape[1]):
        ax[-1][x].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[186]:
    [[file:figure/deconvolution.org/ipsc-unimix-examples.png]]
    :END:

    Print out the last histogram for inspection

    #+BEGIN_SRC ipython
      np.vstack((h[1][:-1], h[0])).T.astype(int)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[189]:
    #+BEGIN_EXAMPLE
      array([[  0,   9],
      [  1,  32],
      [  2,  65],
      [  3,  89],
      [  4, 127],
      [  5, 149],
      [  6, 199],
      [  7, 195],
      [  8, 221],
      [  9, 239],
      [ 10, 277],
      [ 11, 288],
      [ 12, 293],
      [ 13, 293],
      [ 14, 281],
      [ 15, 263],
      [ 16, 321],
      [ 17, 247],
      [ 18, 236],
      [ 19, 236],
      [ 20, 191],
      [ 21, 178],
      [ 22, 168],
      [ 23, 154],
      [ 24, 126],
      [ 25, 124],
      [ 26, 100],
      [ 27,  81],
      [ 28,  67],
      [ 29,  72],
      [ 30,  47],
      [ 31,  41],
      [ 32,  33],
      [ 33,  35],
      [ 34,  21],
      [ 35,  15],
      [ 36,  18],
      [ 37,  13],
      [ 38,   6],
      [ 39,   5],
      [ 40,   7],
      [ 41,   7],
      [ 42,   5],
      [ 43,   5],
      [ 44,   6],
      [ 45,   3],
      [ 46,   3],
      [ 47,   0],
      [ 48,   2],
      [ 49,   0],
      [ 50,   0],
      [ 51,   1],
      [ 52,   0],
      [ 53,   0],
      [ 54,   0],
      [ 55,   1],
      [ 56,   0],
      [ 57,   0],
      [ 58,   0],
      [ 59,   0],
      [ 60,   0],
      [ 61,   0],
      [ 62,   0],
      [ 63,   2]])
    #+END_EXAMPLE
    :END:

    - /SLC25A5/ ([[https://www.omim.org/entry/300150][Solute carrier family 25
      member 5]]) codes for a mitochrondrial membrane protein
      ([[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5789311/][Rocha et
      al. 2018]]), and is altered in Parkinson's disease
    - /TXNDC17/ ([[https://www.omim.org/entry/616967][Thioredoxin
      domain-containing protein 17]]) appears to be involved in oxidative
      stress
    - /PCBP2/ ([[https://www.omim.org/entry/601210][Poly(rC)-binding protein
      2]]) is involved in post-transcriptional regulation

    In iPSC, several genes appear to be better fit by NPMLE than other methods.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/ipsc-npmle-examples.png
      llik_diff = benchmark['ipsc']['npmle'] - benchmark['ipsc']['nb']
      query = benchmark['ipsc'].loc[llik_diff[llik_diff > 0].sort_values(ascending=False).head(n=12).index].index
      plt.clf()
      fig, ax = plt.subplots(3, 4)
      fig.set_size_inches(7, 5)
      for a, k in zip(ax.ravel(), query):
        a.hist(ipsc_counts.loc[:,k], bins=np.arange(ipsc_counts.loc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta L$={llik_diff.loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(gene_info.loc[k, 'name'])
      for y in range(ax.shape[0]):
        ax[y][0].set_ylabel('Number of cells')
      for x in range(ax.shape[1]):
        ax[-1][x].set_xlabel('Num mols')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[192]:
    [[file:figure/deconvolution.org/ipsc-npmle-examples.png]]
    :END:

    Overall, these examples suggest flexibility is needed for accurately
    modeling the tails of the distribution.

** Synthetic cell mixtures
*** T cell-B cell mixture

    Create a synthetic heterogeneous population of cells by combining sorted
    CD8+ T cells and CD19+ B cells from
    [[https://www.nature.com/articles/ncomms14049][Zheng et al. 2017]].

    #+NAME: run-synthetic-mix-benchmark-gpu
    #+BEGIN_SRC ipython :eval never
      t_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True)
      b_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True)
      x, y = scmodes.dataset.synthetic_mix(t_cells, b_cells)
      res = evaluate_generalization(x.values, stratify=y, train_size=0.5, test_size=0.1, random_state=0, methods=['gamma', 'point_gamma'])
      res.to_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/cd8-cd19-mix-gpu.txt.gz', compression='gzip', sep='\t')
    #+END_SRC

    #+RESULTS: run-synthetic-mix-benchmark
    :RESULTS:
    # Out[82]:
    :END:

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
     sbatch --partition=gpu2 --gres=gpu:1 --mem=16G --time=6:00:00 --job-name=benchmark --output=benchmark.out
     #!/bin/bash
     module load cuda/9.0
     source activate scmodes
     python -i <<EOF
     <<run-synthetic-mix-benchmark-gpu>>
     EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59493577

*** Naive/activated T cell mixture

    Create a synthetic mixture of cells by combining sorted
    CD8+ cytotoxic T cells and CD8+/CD45RA+ naive cytotoxic T cells
    [[https://www.nature.com/articles/ncomms14049][Zheng et al. 2017]].

    #+BEGIN_SRC ipython :tangle /project2/mstephens/aksarkar/projects/singlecell-modes/code/benchmark.py
     def cyto_naive_t_mix():
       cyto = read_10x(prefix='/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19', return_df=True)
       naive = read_10x(prefix='/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/naive_cytotoxic/filtered_matrices_mex/hg19', return_df=True)
       x = pd.concat([cyto, naive], axis='index', join='inner')
       y = np.zeros(x.shape[0]).astype(int)
       y[:cyto.shape[0]] = 1
       return x, y
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[3]:
    :END:

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
     sbatch --partition=gpu2 --gres=gpu:1 --mem=16G --time=6:00:00 --job-name=benchmark --output=benchmark-gpu.out
     #!/bin/bash
     source activate scmodes
     python -i /project2/mstephens/aksarkar/projects/singlecell-modes/code/benchmark.py <<EOF
     x, y = cyto_naive_t_mix()
     res = evaluate_generalization(x.values, pool=None, stratify=y, train_size=0.5, test_size=0.1, random_state=0, methods=['nb', 'zinb'])
     res.index = x.columns
     res.to_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/cyto-naive-t-mix-gpu.txt.gz', compression='gzip', sep='\t')
     EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59268870

    #+BEGIN_SRC sh
     sbatch --partition=broadwl -a 0-3 -n1 -c28 --exclusive --mem=16G --time=6:00:00 --job-name=benchmark --output=benchmark-cpu.out
     #!/bin/bash
     source activate scmodes
     python -i /project2/mstephens/aksarkar/projects/singlecell-modes/code/benchmark.py <<EOF
     import os
     cpu_methods = ['unimix', 'descend', 'npmle', 'saturated']
     task = int(os.environ['SLURM_ARRAY_TASK_ID'])
     with mp.Pool(maxtasksperchild=10) as pool:
       x, y = cyto_naive_t_mix()
       res = evaluate_generalization(x.values, pool=pool, stratify=y, train_size=0.5, test_size=0.1, random_state=0, methods=cpu_methods[task:task + 1])
       res.index = x.columns
       res.to_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/cyto-naive-t-mix-{cpu_methods[task]}.txt.gz', compression='gzip', sep='\t')
     EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 59268928

    Read the results.

    #+BEGIN_SRC ipython
     benchmark = {}
     benchmark['cd8-cd19-mix'] = pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/cd8-cd19-mix.txt.gz', sep='\t', index_col=0)
     benchmark['cyto-naive-t-mix'] = (
       pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/cyto-naive-t-mix-gpu.txt.gz', sep='\t')
       .merge(pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/cyto-naive-t-mix-unimix.txt.gz', sep='\t'), on='0')
       .merge(pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/cyto-naive-t-mix-descend.txt.gz', sep='\t'), on='0')
       .merge(pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/cyto-naive-t-mix-npmle.txt.gz', sep='\t'), on='0')
       .merge(pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/cyto-naive-t-mix-saturated.txt.gz', sep='\t'), on='0')
       .set_index('0'))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[4]:
    :END:

    Plot the results.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/synthetic-mix-benchmark.png
     fig, ax = plt.subplots(1, 2, sharey=True)
     fig.set_size_inches(5, 3)
     for a, k in zip(ax, sorted(benchmark.keys())):
       a.boxplot((benchmark[f'{k}'].values - benchmark[f'{k}']['nb'].values.reshape(-1, 1))[:,1:-1],
                 widths=0.25, medianprops={'color': 'k'}, flierprops={'marker': '.', 'markersize': 4})
       a.set_xticklabels(['ZINB', 'Unimodal', 'ZIEF', 'NPMLE'], rotation=90)
       a.set_xlabel('Assumed latent dist')
       a.set_title(k)
     ax[0].set_ylabel('Diff val set log lik from NB')
     fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[197]:
    [[file:figure/deconvolution.org/synthetic-mix-benchmark.png]]
    :END:

    Zoom in on the relevant part of the plot.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/synthetic-mix-benchmark-inset.png
     fig, ax = plt.subplots(1, 2)
     fig.set_size_inches(5, 3)
     for a, k in zip(ax, sorted(benchmark.keys())):
       T = (benchmark[f'{k}'].values - benchmark[f'{k}']['nb'].values.reshape(-1, 1))[:,1:-1]
       a.boxplot(T, widths=0.25, medianprops={'color': 'k'}, flierprops={'marker': '.', 'markersize': 4})
       a.axhline(y=0, ls=':', lw=1, c='k')
       a.set_xticklabels(['ZINB', 'Unimodal', 'ZIEF', 'NPMLE'], rotation=90)
       a.set_xlabel('Assumed latent dist')
       a.set_ylim(-20, 1.05 * T.max())
       a.set_title(k)
     ax[0].set_ylabel('Diff val set log lik from NB')
     fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[202]:
    [[file:figure/deconvolution.org/synthetic-mix-benchmark-inset.png]]
    :END:

*** Investigate genes favoring more complex models

    Read the data.

    #+BEGIN_SRC ipython :async t
      mix1, y1 = cd8_cd19_mix()
      mix2, y2 = cyto_naive_t_mix()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[7]:
    :END:

    Look at genes where NPMLE has higher validation set log likelihood than NB.

    #+BEGIN_SRC ipython
      llik_diff = benchmark['cd8-cd19-mix']['npmle'] - benchmark['cd8-cd19-mix']['nb']
      query = benchmark['cd8-cd19-mix'].loc[llik_diff[llik_diff > 0].sort_values(ascending=False).head(n=12).index].index
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[23]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cd8-cd19-mix-npmle-examples.png
      plt.clf()
      fig, ax = plt.subplots(3, 4)
      fig.set_size_inches(8, 6)
      for a, k in zip(ax.ravel(), query):
        a.hist(mix1.iloc[:,k], bins=np.arange(mix1.iloc[:,k].max() + 1), color='k')
        a.text(x=.95, y=.95,
               s=f"$\Delta L$={benchmark['cd8-cd19-mix']['npmle'].loc[k] - benchmark['cd8-cd19-mix']['nb'].loc[k]:.1f}",
               horizontalalignment='right',
               verticalalignment='top',
               transform=a.transAxes)
        a.set_title(gene_info.loc[mix1.columns[k], 'name'] if mix1.columns[k] in gene_info.index else mix1.columns[k])
        a.set_xlabel('Number of molecules')
      for a in ax:
        a[0].set_ylabel('Number of cells')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[25]:
    [[file:figure/deconvolution.org/cd8-cd19-mix-npmle-examples.png]]
    :END:

    Look at /CD74/ gene expression, stratified by known cell type.

    #+BEGIN_SRC ipython :ipyfile figure/deconvolution.org/cd74-example.png
      plt.clf()
      fig, ax = plt.subplots(1, 2, sharey=True)
      fig.set_size_inches(5, 2)
      for i, a in enumerate(ax):
        a.hist(mix1.loc[y1 == i,mix1.columns[query[0]]], bins=np.arange(mix1.loc[:,mix1.columns[query[0]]].max() + 1), color='k')
        a.set_title(['T cells', 'B cells'][i])
        a.set_xlabel('Number of molecules')
      ax[0].set_ylabel('Number of cells')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[31]:
    : Text(0, 0.5, 'Number of cells')
    [[file:figure/deconvolution.org/cd74-example.png]]
    :END:

** Heterogeneous cell populations

   #+BEGIN_SRC ipython :tangle /project2/mstephens/aksarkar/projects/singlecell-modes/code/benchmark.py
     def pbmcs_68k(**kwargs):
       return read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/fresh_68k_pbmc_donor_a/filtered_matrices_mex/hg19', **kwargs)

     def cortex(return_df=False):
       counts = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/zeisel-2015/GSE60361_C1-3005-Expression.txt.gz', index_col=0, sep='\t')
       # Follow scVI here
       subset = counts.loc[counts.var(axis=1).sort_values(ascending=False).head(n=500).index].T
       if return_df:
         return subset
       else:
         return subset.values
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[3]:
   :END:

   #+NAME: heterogeneous-benchmark-gpu
   #+BEGIN_SRC ipython :eval never
     for data in ('pbmcs_68k', 'cortex'):
       x = globals()[data](return_df=True)
       res = evaluate_generalization(x.values, pool=None, test_size=0.1, random_state=0, methods=['nb', 'zinb'])
       res.index = x.columns
       res.to_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-gpu.txt.gz', compression='gzip', sep='\t')
   #+END_SRC

   #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
     sbatch --partition=gpu2 --gres=gpu:1 --mem=16G --time=6:00:00 --job-name=benchmark --output=benchmark-gpu.out
     #!/bin/bash
     source activate scmodes
     python -i /project2/mstephens/aksarkar/projects/singlecell-modes/code/benchmark.py <<EOF
     <<heterogeneous-benchmark-gpu>>
     EOF
   #+END_SRC

   #+RESULTS:
   : Submitted batch job 59288128

   #+NAME: heterogeneous-benchmark-cpu
   #+BEGIN_SRC ipython :eval never
     import os
     datasets = ['pbmcs_68k', 'cortex']
     cpu_methods = ['unimix', 'descend', 'npmle', 'saturated']
     tasks = [(d, c) for d in datasets for c in cpu_methods]
     data, method = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
     with mp.Pool() as pool:
       x = globals()[data](return_df=True)
       res = evaluate_generalization(x.values, pool=pool, train_size=0.5, test_size=0.1, random_state=0, methods=[method])
       res.index = x.columns
       res.to_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/deconv-generalization/{data}-{method}.txt.gz', compression='gzip', sep='\t')
   #+END_SRC

   #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
     sbatch --partition=broadwl -a 0 -n1 -c28 --exclusive --mem=16G --time=6:00:00 --job-name=benchmark --output=benchmark-cpu.out
     #!/bin/bash
     source activate scmodes
     python -i /project2/mstephens/aksarkar/projects/singlecell-modes/code/benchmark.py <<EOF
     <<heterogeneous-benchmark-cpu>>
     EOF
   #+END_SRC

   #+RESULTS:
   : Submitted batch job 59340657

