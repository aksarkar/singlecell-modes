#+TITLE: Goodness of fit of deconvolved distributions
#+SETUPFILE: setup.org

* Introduction

  We [[file:deconvolution.org][previously estimated]] the out-of-sample log likelihood as a measure of the
  generalization performance of distribution deconvolution methods for
  scRNA-seq. However, this is not the simplest way to support some of our key
  results:

  1. For most genes, in most data sets, a Gamma assumption appears sufficient
     (meaning, more complicated distributional assumptions do not have better
     generalization performance).
  2. When Gamma is insufficient, it is generally not the case that assuming a
     point mass on zero improves generalization (meaning, departures from Gamma
     do not involve excess zeros).

  Here, we directly test for the goodness of fit of the estimated distribution
  (as in [[https://dx.doi.org/10.1371/journal.pgen.1008045][Sarkar et al. 2019]]).

* Setup
  :PROPERTIES:
  :CUSTOM_ID: setup
  :END:

  #+BEGIN_SRC emacs-lisp :exports none
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(venv="scmodes",partition="mstephens",memory="16G") :exports none :dir /scratch/midway2/aksarkar/modes/

  #+RESULTS:
  : Submitted batch job 62738644

  #+NAME: imports
  #+BEGIN_SRC ipython
    import numpy as np
    import pandas as pd
    import scmodes
  #+END_SRC

  #+RESULTS: imports
  :RESULTS:
  # Out[2]:
  :END:

  #+BEGIN_SRC ipython
    import scipy.special as sp
    import scqtl
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[3]:
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[4]:
  :END:

  #+BEGIN_SRC ipython
    import matplotlib.pyplot as plt
    plt.rcParams['figure.facecolor'] = 'w'
    plt.rcParams['font.family'] = 'Nimbus Sans'
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[5]:
  :END:

* Methods
** Test for goodness of fit

  The key idea underlying our test for goodness of fit is the fact that if
  \(x_{i} \sim F(\cdot)\), then $F(x_{i}) \sim \operatorname{Uniform}(0,
  1)$. To test for goodness of fit of an estimated \(\hat{F}\) to the data
  \(x_{1}, \ldots, x_{n}\), we apply the Kolmogorov-Smirnov (KS) test to test
  whether the values \(\hat{F}(x_1), \ldots, \hat{F}(x_n)\) are uniformly
  distributed. (This test is slightly conservative because it uses the same
  data to estimate \(\hat{F}\).)

  Here, we have to modify this simple procedure to account for the fact that
  our data are discrete counts, so $F$ is not continuous. To address this
  issue, we used randomized quantiles ([[https://www.jstor.org/stable/1390802][Dunn 1996]]): we sample one random value
  per observation \(u_{i} \mid x_{i} \sim \mathrm{Uniform}(\hat{F}(x_i - 1),
  \hat{F}(x_i))\). These have the property that if \(x_i \sim F\) then \(u_i
  \sim \mathrm{Uniform}(0, 1)\).

  In our model, each observed UMI count \(x_{i}\) comes from a different
  distribution \(F_{i}\):

  \[ F_i(x_i) = \sum_{k=0}^{x_i} \int_0^\infty \operatorname{Poisson}(k; s_i
  \lambda_i) g(d\lambda_i) \]

  We therefore draw \(u_{i} \mid x_{i} \sim
  \mathrm{Uniform}(\hat{F}_{i}(x_{i} - 1), \hat{F}_{i}(x_{i}))\). Then, we
  apply the KS test to whether the randomized quantiles \(u_{i}\) are uniformly
  distributed.

** Poisson-unimodal goodness of fit

   We parameterized the Poisson-unimodal model as:

   \begin{align*}
     x_i &\sim \operatorname{Poisson}(s_i \lambda_i)\\
     \lambda_i &\sim \sum_k w_k \operatorname{Uniform}(\lambda_0, a_k)
   \end{align*}

   where we abuse notation to allow \(a_k < \lambda_0\). To test for goodness
   of fit, we need the PMF and CDF of \(x_i\), marginalized over
   \(\lambda_i\). [[https://lsun.github.io/truncash/diagnostic_plot.html#ash:_(t)_likelihood,_uniform_mixture_prior][These
   are analytic for certain choices of likelihood and prior.]] In this case, we
   have (for one component):

   \begin{align*}
     x_i &\sim \operatorname{Poisson}(s_i \lambda_i)\\
     \lambda_i &\sim \operatorname{Uniform}(a, b)
   \end{align*}

   and:

   \begin{align*}
     \Pr(x_i = x) &= \int_0^\infty \operatorname{Poisson}(x_i; s_i \lambda_i) \operatorname{Uniform}(a, b) d\lambda_i\\
     &= \frac{1}{b - a} \int_a^b \operatorname{Poisson}(x_i; s_i \lambda_i) d\lambda_i\\
     &= \frac{1}{s_i (b - a)} \int_a^b \frac{s_i^{x_i + 1}}{\Gamma(x_i + 1)} \lambda_i^{(x_i + 1) - 1}\exp(-s_i\lambda_i) d\lambda_i\\
     &= \frac{1}{s_i (b - a)} \left( F_\Gamma(b; x_i + 1, s_i) - F_\Gamma(a, x_i + 1, s_i) \right)\\
     \Pr(x_i \leq x) &= \sum_{k=0}^{x} \frac{1}{s_i (b - a)} \left( F_\Gamma(b; k + 1, s_i) - F_\Gamma(a, k + 1, s_i) \right)\\
   \end{align*}

   where \(F_\Gamma(\cdot; \alpha, \beta)\) denotes the CDF of the Gamma
   distribution with shape \(\alpha\) and rate \(\beta\). The marginal PMF is
   analytic. Computing the CDF for each data point, for each component gives a
   matrix of values \(\mathbf{F} = [F_{ik}]\). Then, the marginal CDF of the
   data is given by \(\mathbf{F}\mathbf{w}\).

** Data

   #+NAME: data
   #+BEGIN_SRC ipython
     def _cd8_cd19_mix(return_y=False):
       t_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True, min_detect=0)
       b_cells = scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True, min_detect=0)
       x, y = scmodes.dataset.synthetic_mix(t_cells, b_cells, min_detect=0.25)
       if return_y:
         return x, y
       else:
         return x

     def _cyto_naive_mix():
       cyto = scmodes.dataset.read_10x(prefix='/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19', return_df=True, min_detect=0)
       naive = scmodes.dataset.read_10x(prefix='/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/naive_t/filtered_matrices_mex/hg19', return_df=True, min_detect=0)
       return scmodes.dataset.synthetic_mix(cyto, naive, min_detect=0.25)[0]

     data = {
       'cytotoxic_t': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/cytotoxic_t/filtered_matrices_mex/hg19/', return_df=True),
       'b_cells': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/b_cells/filtered_matrices_mex/hg19/', return_df=True),
       'ipsc': lambda: scmodes.dataset.ipsc('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/', n=100, return_df=True),
       'cytotoxic_t-b_cells': _cd8_cd19_mix,
       'cytotoxic_t-naive_t': _cyto_naive_mix,
       'pbmcs_68k': lambda: scmodes.dataset.read_10x('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/fresh_68k_pbmc_donor_a/filtered_matrices_mex/hg19', return_df=True),
     }
   #+END_SRC

   #+RESULTS: data
   :RESULTS:
   # Out[12]:
   :END:

* Results
** Simulation
   :PROPERTIES:
   :CUSTOM_ID: simulation
   :END:

   Draw data following the Poisson-point Gamma distribution:

   \begin{align*}
     x_i &\sim \operatorname{Poisson}(s_i \lambda_i)\\
     \lambda_i &\sim \pi \delta_0(\cdot) + (1 - \pi) \operatorname{Gamma}(1/\phi, 1/(\mu\phi))
   \end{align*}

   Draw simulation parameters \(s_i=10^5, \ln\mu, \ln\phi\) from typical values
   (Sarkar et al. 2019).

   \begin{align*}
     \ln\mu &\sim \operatorname{Uniform}(-12, -8)\\
     \ln\phi &\sim \operatorname{Uniform}(-6, 0)
   \end{align*}

   Then, test for goodness of fit of Poisson-Gamma and Poisson-point Gamma.

   #+BEGIN_SRC ipython
     import rpy2.robjects.packages
     import rpy2.robjects.pandas2ri
     import scmodes.benchmark.gof

     ashr = rpy2.robjects.packages.importr('ashr')

     def trial(num_samples, logodds, seed, verbose=False):
       data, _ = scqtl.simulation.simulate(num_samples=num_samples, logodds=logodds, seed=seed)
       x = data[:,0]
       s = data[:,1]
       # Important: scqtl.simple returns mu, 1/phi
       fit0 = scqtl.simple.fit_nb(x, s)
       res0 = scmodes.benchmark.gof._gof(x, cdf=scmodes.benchmark.gof._zig_cdf,
                                         pmf=scmodes.benchmark.gof._zig_pmf, size=s,
                                         log_mu=np.log(fit0[0]), log_phi=-np.log(fit0[1]))
       fit1 = scqtl.simple.fit_zinb(x, s)
       res1 = scmodes.benchmark.gof._gof(x, cdf=scmodes.benchmark.gof._zig_cdf,
                                         pmf=scmodes.benchmark.gof._zig_pmf, size=s,
                                         log_mu=np.log(fit1[0]), log_phi=-np.log(fit1[1]), logodds=fit1[2])

       res2 = scmodes.benchmark.gof._gof_unimodal("", x, s)
       return res0[1], res1[1], res2[1]

     def evaluate(num_samples, num_trials):
       result = []
       for logodds in np.linspace(-5, 0, 10):
         for seed in range(num_trials):
           gamma_res, zig_res = trial(num_samples, logodds, seed)
           result.append([logodds, seed, gamma_res, zig_res])
       result = pd.DataFrame(result)
       result.columns = ['logodds', 'trial', 'gamma', 'zig', 'unimodal']
       return result
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[5]:
   :END:

   Run the simulation.

   #+BEGIN_SRC ipython :async t
     sim_res = evaluate(num_samples=1000, num_trials=10)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[42]:
   :END:

   Write out the results.

   #+BEGIN_SRC ipython
     sim_res.to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/gof/simulation.txt.gz', sep='\t', compression='gzip')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[43]:
   :END:

   Read the results.

   #+BEGIN_SRC ipython
     sim_results = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/gof/simulation.txt.gz', sep='\t', compression='gzip', index_col=0)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[44]:
   :END:

   Plot the results.

   #+BEGIN_SRC ipython :ipyfile figure/gof.org/sim.png
     cm = plt.get_cmap('Dark2')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i, (k, l) in enumerate(zip(['gamma', 'zig'], ['Gamma', 'ZIG'])):
       jitter = np.random.normal(scale=0.01, size=sim_res.shape[0])
       plt.scatter(sim_res['logodds'] + jitter, -np.log10(sim_res[k]), s=2, c=np.atleast_2d(cm(i)), label=l)
     plt.axhline(y=0, c='k', lw=1)
     plt.axhline(y=-np.log10(.05), c='0.8', ls='--', lw=1)
     plt.legend(frameon=False, handletextpad=0, markerscale=4)
     plt.xticks(np.linspace(-5, 0, 10), [f'{x:.2g}' for x in sp.expit(np.linspace(-5, 0, 10))], rotation=90)
     plt.xlabel('$\pi$')
     plt.ylabel('Goodness of fit $-\log_{10}(p)$')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[51]:
   [[file:figure/gof.org/sim.png]]
   :END:

   Plot a zoomed-in version of the results.

   #+BEGIN_SRC ipython :ipyfile figure/gof.org/sim-inset.png
     cm = plt.get_cmap('Dark2')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i, (k, l) in enumerate(zip(['gamma', 'zig'], ['Gamma', 'ZIG'])):
       jitter = np.random.normal(scale=0.01, size=sim_res.shape[0])
       plt.scatter(sim_res['logodds'] + jitter, -np.log10(sim_res[k]), s=2, c=np.atleast_2d(cm(i)), label=l)
     plt.axhline(y=0, c='k', lw=1)
     plt.axhline(y=-np.log10(.05), c='0.8', ls='--', lw=1)
     plt.legend(frameon=False, handletextpad=0, markerscale=4)
     plt.xticks(np.linspace(-5, 0, 10), [f'{x:.2g}' for x in sp.expit(np.linspace(-5, 0, 10))], rotation=90)
     plt.xlabel('$\pi$')
     plt.ylim(0, 10)
     plt.ylabel('Goodness of fit $-\log_{10}(p)$')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[52]:
   [[file:figure/gof.org/sim-inset.png]]
   :END:

** Test for goodness of fit
   :PROPERTIES:
   :CUSTOM_ID: gof
   :END:

   Run the GPU-based methods.

   #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
     sbatch --partition=gpu2 --gres=gpu:1 --mem=16G --time=4:00:00 -a 1-5
     #!/bin/bash
     source activate scmodes
     python <<EOF
     <<imports>>
     import os
     <<data>>
     tasks = list(data.keys())
     task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
     x = data[task]()
     res = scmodes.benchmark.evaluate_gof(x, methods=['gamma', 'zig'])
     res.to_csv(f'/scratch/midway2/aksarkar/modes/gof/{task}-gpu.txt.gz', compression='gzip', sep='\t')
     EOF
   #+END_SRC

   #+RESULTS:
   : Submitted batch job 62661167

   Run the CPU methods

   #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
     sbatch --partition=broadwl -n1 -c28 --exclusive --time=12:00:00 -a 0
     #!/bin/bash
     source activate scmodes
     python <<EOF
     <<imports>>
     import multiprocessing as mp
     import os
     <<data>>
     tasks = list(data.keys())
     task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
     with mp.Pool(maxtasksperchild=20) as pool:
       # Important: this needs to be done after initializing the pool to avoid
       # memory duplication
       x = data[task]()
       res = scmodes.benchmark.evaluate_gof(x, pool=pool, methods=['unimodal'])
       res.index = x.columns
       res.to_csv(f'/scratch/midway2/aksarkar/modes/gof/{task}-unimodal.txt.gz', compression='gzip', sep='\t')
     EOF
   #+END_SRC

   #+RESULTS:
   : Submitted batch job 62671900

   Move the results to permanent storage.

   #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/modes/
     rsync -au /scratch/midway2/aksarkar/modes/gof/ /project2/mstephens/aksarkar/projects/singlecell-modes/data/gof/
   #+END_SRC

   #+RESULTS:

   Read the results.

   #+BEGIN_SRC ipython
     gof_res = (pd.concat([pd.read_csv(f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/gof/{k}-gpu.txt.gz',
                                      sep='\t', index_col=0) for k in data],
                          keys=data.keys())
                .reset_index(level=0)
                .rename({'level_0': 'dataset'}, axis='columns'))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[8]:
   :END:

   Plot the histogram of goodness of fit test \(p\)-values for the fitted Gamma
   distribution.

   #+BEGIN_SRC ipython :ipyfile figure/gof.org/gamma-gof-hist.png
     plt.clf()
     fig, ax = plt.subplots(2, 3, sharex=True)
     fig.set_size_inches(6, 4)
     for a, t, (k, g) in zip(ax.ravel(),
                             ['T cell', 'B cell', 'iPSC', 'T cell/B cell', 'Cytotoxic/naive T', 'PBMC'],
                             gof_res.groupby('dataset')):
       a.hist(g.loc[g['method'] == 'gamma', 'p'], bins=10, color='0.7', density=True)
       a.axhline(y=1, c='k', ls=':', lw=1)
       a.set_xlim([0, 1])
       a.set_title(t)
     for a in ax:
       a[0].set_ylabel('Density')
     for a in ax.T:
       a[-1].set_xlabel('$p$-value')
     fig.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[8]:
   [[file:figure/gof.org/gamma-gof-hist.png]]
   :END:

   Plot the histogram of goodness of fit test \(p\)-values for the fitted
   point-Gamma distribution.

   #+BEGIN_SRC ipython :ipyfile figure/gof.org/zig-gof-hist.png
     plt.clf()
     fig, ax = plt.subplots(2, 3, sharex=True)
     fig.set_size_inches(6, 4)
     for a, t, (k, g) in zip(ax.ravel(),
                             ['T cell', 'B cell', 'iPSC', 'T cell/B cell', 'Cytotoxic/naive T', 'PBMC'],
                             gof_res.groupby('dataset')):
       a.hist(g.loc[g['method'] == 'zig', 'p'], bins=10, color='0.7', density=True)
       a.axhline(y=1, c='k', ls=':', lw=1)
       a.set_xlim([0, 1])
       a.set_title(t)
     for a in ax:
       a[0].set_ylabel('Density')
     for a in ax.T:
       a[-1].set_xlabel('$p$-value')
     fig.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[10]:
   [[file:figure/gof.org/zig-gof-hist.png]]
   :END:

   Report the number of genes which depart from the null that the data for the
   gene follows the fitted distribution (after Bonferroni correction at level
   0.05).

   #+BEGIN_SRC ipython
     gof_res.groupby(['dataset', 'method']).apply(lambda x: (x['p'] < 0.05 / x.shape[0]).sum()).reset_index().pivot(index='dataset', columns='method')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[11]:
   #+BEGIN_EXAMPLE
     0
     method              gamma  zig
     dataset
     b_cells                12   10
     cytotoxic_t             7    6
     cytotoxic_t-b_cells    35   24
     cytotoxic_t-naive_t    29   28
     ipsc                    2    2
     pbmcs_68k             108  109
   #+END_EXAMPLE
   :END:

   Report the fraction of genes which depart from the null that the data for
   the gene follows the fitted distribution (after Bonferroni correction at
   level 0.05).

   #+BEGIN_SRC ipython
     gof_res.groupby(['dataset', 'method']).apply(lambda x: (x['p'] < 0.05 / x.shape[0]).mean()).reset_index().pivot(index='dataset', columns='method')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[12]:
   #+BEGIN_EXAMPLE
     0
     method                  gamma       zig
     dataset
     b_cells              0.032000  0.026667
     cytotoxic_t          0.015184  0.013015
     cytotoxic_t-b_cells  0.086634  0.059406
     cytotoxic_t-naive_t  0.069212  0.066826
     ipsc                 0.037736  0.037736
     pbmcs_68k            0.267327  0.269802
   #+END_EXAMPLE
   :END:

   *Remark* We previously fit point-Gamma distributions to the iPSC data
   (Sarkar et al. 2019), and [[https://jdblischak.github.io/singlecell-qtl/zinb.html#org17af587][reported]]:

   #+BEGIN_QUOTE
   We tested the goodness of fit for each individual and each gene, and
   rejected the null that the model fit the data for only 60 of 537,658
   individual-gene combinations (0.01%) after Bonferroni correction ($p < 9
   \times 10^{−8}$)
   #+END_QUOTE

   The key difference between the approach taken here and the previous result
   is that here we do not account for the fact that the cells are derived from
   multiple donors. The differing genetic backgrounds of the donor individuals
   means both the mean and variance of gene expression vary, such that the
   marginal distribution is not well-described by a single Gamma distribution.

** Examples
   :PROPERTIES:
   :CUSTOM_ID: examples
   :END:

   Look at genes which significantly depart from Gamma, but not from
   point-Gamma.

   #+BEGIN_SRC ipython
     sig0 = gof_res[gof_res['method'] == 'gamma'].groupby('dataset').apply(lambda x: x.loc[x['p'] < 0.05 / x.shape[0]]).reset_index(drop=True)
     nsig1 = gof_res[gof_res['method'] == 'zig'].groupby('dataset').apply(lambda x: x.loc[x['p'] >= 0.05 / x.shape[0]]).reset_index(drop=True)
     examples = sig0.merge(nsig1, on=['dataset', 'gene'], suffixes=['_gamma', '_zig'])
     del examples['method_gamma']
     del examples['method_zig']
     examples.sort_values('p_gamma').head()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[25]:
   #+BEGIN_EXAMPLE
     dataset             gene  stat_gamma        p_gamma  stat_zig  \
     6   cytotoxic_t-b_cells  ENSG00000204287    0.181818   0.000000e+00  0.011718
     11  cytotoxic_t-b_cells  ENSG00000231389    0.095940  1.125366e-162  0.010051
     17  cytotoxic_t-b_cells  ENSG00000105369    0.093518  1.383684e-154  0.014097
     16  cytotoxic_t-b_cells  ENSG00000007312    0.072012   7.766159e-92  0.006933
     7   cytotoxic_t-b_cells  ENSG00000198502    0.066750   5.775193e-79  0.008084

     p_zig
     6   0.007598
     11  0.033140
     17  0.000628
     16  0.283539
     7   0.140896
   #+END_EXAMPLE
   :END:

   The top examples come from the T cell/B cell mixture.

   #+BEGIN_SRC ipython :async t
     mix_x, mix_y = _cd8_cd19_mix(return_y=True)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[13]:
   :END:

   #+BEGIN_SRC ipython
     gene_info = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-genes.txt.gz', sep='\t', index_col=0)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[14]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/gof.org/examples.png
     plt.clf()
     fig, ax = plt.subplots(2, 2)
     fig.set_size_inches(4, 4)
     for a, k in zip(ax.ravel(), examples.sort_values('p_gamma')['gene'].head(n=4)):
       for i, (l, c) in enumerate(zip(['B cell', 'T cell'], ['r', 'k'])):
         x = mix_x.loc[mix_y == i,k]
         a.hist(x, bins=np.arange(x.max() + 1), color=c, label=l, alpha=0.5)
         a.set_title(gene_info.loc[k, 'name'])
     for a in ax:
       a[0].set_ylabel('Number of cells')
     for a in ax.T:
       a[-1].set_xlabel('Number of molecules')
     ax[0,0].legend(frameon=False)
     fig.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[38]:
   [[file:figure/gof.org/examples.png]]
   :END:
