#+TITLE: Goodness of fit of deconvolved distributions
#+SETUPFILE: setup.org

* Introduction

  We [[file:deconvolution.org][previously estimated]] the out-of-sample log likelihood as a measure of the
  generalization performance of distribution deconvolution methods for
  scRNA-seq. However, this is not the simplest way to support our key results:

  1. For spike-ins (control experiments), the data do not depart from a
     unimodal distribution for expression variation (meaning, neither
     sequencing variation nor expression variation involve a point mass on
     zero).
  2. For most genes, in most data sets, a Gamma assumption appears sufficient
     (meaning, the data do not significantly depart from the fitted model).

  Here, we directly test for the goodness of fit of the estimated distribution
  (as in [[https://dx.doi.org/10.1371/journal.pgen.1008045][Sarkar et al. 2019]]).

* Setup
  :PROPERTIES:
  :CUSTOM_ID: setup
  :END:

  #+BEGIN_SRC emacs-lisp :exports none
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(venv="scmodes",partition="mstephens",memory="16G") :exports none :dir /scratch/midway2/aksarkar/modes/

  #+RESULTS:
  : Submitted batch job 63794398

  #+NAME: imports
  #+BEGIN_SRC ipython
    import numpy as np
    import pandas as pd
    import scanpy
    import scmodes
  #+END_SRC

  #+RESULTS: imports
  :RESULTS:
  # Out[1]:
  :END:

  #+BEGIN_SRC ipython
    import os
    import scipy.io as si
    import scipy.special as sp
    import scipy.stats as st
    import scqtl
    import sqlite3
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[2]:
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[3]:
  :END:

  #+BEGIN_SRC ipython
    import matplotlib.pyplot as plt
    plt.rcParams['figure.facecolor'] = 'w'
    plt.rcParams['font.family'] = 'Nimbus Sans'
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[4]:
  :END:

* Methods
** Test for goodness of fit

  The key idea underlying our test for goodness of fit is the fact that if
  \(x_{i} \sim F(\cdot)\), then $F(x_{i}) \sim \operatorname{Uniform}(0,
  1)$. To test for goodness of fit of an estimated \(\hat{F}\) to the data
  \(x_{1}, \ldots, x_{n}\), we apply the Kolmogorov-Smirnov (KS) test to test
  whether the values \(\hat{F}(x_1), \ldots, \hat{F}(x_n)\) are uniformly
  distributed. (This test is slightly conservative because it uses the same
  data to estimate \(\hat{F}\).)

  Here, we have to modify this simple procedure to account for the fact that
  our data are discrete counts, so $F$ is not continuous. To address this
  issue, we used randomized quantiles ([[https://www.jstor.org/stable/1390802][Dunn 1996]]): we sample one random value
  per observation \(u_{i} \mid x_{i} \sim \mathrm{Uniform}(\hat{F}(x_i - 1),
  \hat{F}(x_i))\). These have the property that if \(x_i \sim F\) then \(u_i
  \sim \mathrm{Uniform}(0, 1)\).

  In our model, each observed UMI count \(x_{i}\) comes from a different
  distribution \(F_{i}\):

  \[ F_i(x_i) = \sum_{k=0}^{x_i} \int_0^\infty \operatorname{Poisson}(k; s_i
  \lambda_i) g(d\lambda_i) \]

  We therefore draw \(u_{i} \mid x_{i} \sim
  \mathrm{Uniform}(\hat{F}_{i}(x_{i} - 1), \hat{F}_{i}(x_{i}))\). Then, we
  apply the KS test to whether the randomized quantiles \(u_{i}\) are uniformly
  distributed.

** Poisson-unimodal goodness of fit

   We parameterized the Poisson-unimodal model as:

   \begin{align*}
     x_i &\sim \operatorname{Poisson}(s_i \lambda_i)\\
     \lambda_i &\sim \sum_k w_k \operatorname{Uniform}(\lambda_0, a_k)
   \end{align*}

   where we abuse notation to allow \(a_k < \lambda_0\). To test for goodness
   of fit, we need the PMF and CDF of \(x_i\), marginalized over
   \(\lambda_i\). [[https://lsun.github.io/truncash/diagnostic_plot.html#ash:_(t)_likelihood,_uniform_mixture_prior][These
   are analytic for certain choices of likelihood and prior]], e.g. normal
   likelihood and mixture of uniforms prior.

   Simulate a continuous example.

   #+BEGIN_SRC ipython
     bhat = pd.Series(np.random.normal(loc=0.1, size=1000))
     fitn = ashr.ash_workhorse(bhat, 1, mixcompdist='uniform', output=pd.Series(['loglik', 'fitted_g', 'data']))
     # Important: Normal-uniform convolution CDF is analytic
     F = np.array(fitn.rx2('fitted_g').rx2('pi')).dot(np.array(ashr.comp_cdf_conv(fitn.rx2('fitted_g'), fitn.rx2('data'))))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[113]:
   :END:

   #+BEGIN_SRC ipython
     st.kstest(F, 'uniform')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[116]:
   : KstestResult(statistic=0.03101662170773789, pvalue=0.28605255994768175)
   :END:

   For the Poisson-unimodal model, we have (for one component):

   \begin{align*}
     x_i &\sim \operatorname{Poisson}(s_i \lambda_i)\\
     \lambda_i &\sim \operatorname{Uniform}(a, b)
   \end{align*}

   and:

   \begin{align*}
     \Pr(x_i = x) &= \int_0^\infty \operatorname{Poisson}(x_i; s_i \lambda_i) \operatorname{Uniform}(a, b) d\lambda_i\\
     &= \frac{1}{b - a} \int_a^b \operatorname{Poisson}(x_i; s_i \lambda_i) d\lambda_i\\
     &= \frac{1}{s_i (b - a)} \int_a^b \frac{s_i^{x_i + 1}}{\Gamma(x_i + 1)} \lambda_i^{(x_i + 1) - 1}\exp(-s_i\lambda_i) d\lambda_i\\
     &= \frac{1}{s_i (b - a)} \left( F_\Gamma(b; x_i + 1, s_i) - F_\Gamma(a, x_i + 1, s_i) \right)\\
     \Pr(x_i \leq x) &= \sum_{k=0}^{x} \frac{1}{s_i (b - a)} \left( F_\Gamma(b; k + 1, s_i) - F_\Gamma(a, k + 1, s_i) \right)\\
   \end{align*}

   where \(F_\Gamma(\cdot; \alpha, \beta)\) denotes the CDF of the Gamma
   distribution with shape \(\alpha\) and rate \(\beta\). The marginal PMF is
   analytic. Computing the CDF for each data point, for each component gives a
   matrix of values \(\mathbf{F} = [F_{ik}]\). Then, the marginal CDF of the
   data is given by \(\mathbf{F}\mathbf{w}\).

   Simulate a simple discrete example.

   #+BEGIN_SRC ipython :async t
     y = pd.Series(np.random.poisson(lam=10, size=1000))
     s = pd.Series(np.ones(y.shape))
     fitp = ashr.ash_workhorse(
       np.zeros(y.shape), 1,
       lik=ashr.lik_pois(y=y, scale=s, link='identity'),
       mixcompdist='halfuniform',
       output=pd.Series(['loglik', 'fitted_g', 'data']))
     scmodes.benchmark.gof._gof(y,
       cdf=scmodes.benchmark.gof._ash_cdf,
       pmf=scmodes.benchmark.gof._ash_pmf, fit=fitp, s=s)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[125]:
   : KstestResult(statistic=0.018791616085501672, pvalue=0.8718125394494075)
   :END:

   Simulate a Poisson example with varying size factors.

   #+BEGIN_SRC ipython :async t
     mu = 1e-3
     s = pd.Series(np.random.poisson(lam=1000, size=10000))
     y = pd.Series(np.random.poisson(lam=s * mu))
     fitp = ashr.ash_workhorse(
       np.zeros(y.shape), 1,
       lik=ashr.lik_pois(y=y, scale=s, link='identity'),
       mixcompdist='halfuniform',
       output=pd.Series(['loglik', 'fitted_g', 'data']))
     scmodes.benchmark.gof._gof(y,
       cdf=scmodes.benchmark.gof._ash_cdf,
       pmf=scmodes.benchmark.gof._ash_pmf, fit=fitp, s=s)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[133]:
   : KstestResult(statistic=0.008062709224521236, pvalue=0.533974089244596)
   :END:

** Data

   #+NAME: data
   #+BEGIN_SRC ipython
     def read_chromium(sample):
       x = scanpy.read('/project2/mstephens/aksarkar/projects/singlecell-modes/data/negative-controls/svensson_chromium_control.h5ad')
       x = x[x.obs['sample'] == sample]
       scanpy.pp.filter_genes(x, min_counts=1)
       x = x[:,x.var.filter(like='ERCC', axis='index').index]
       return pd.DataFrame(x.X.A, index=x.obs.index, columns=x.var.index)

     def read_dropseq():
       x = scanpy.read('/project2/mstephens/aksarkar/projects/singlecell-modes/data/negative-controls/macosko_dropseq_control.h5ad')
       scanpy.pp.filter_genes(x, min_counts=1)
       x = x[:,x.var.filter(like='ERCC', axis='index').index]
       return pd.DataFrame(x.X.A, index=x.obs.index, columns=x.var.index)

     def read_indrops():
       x = scanpy.read('/project2/mstephens/aksarkar/projects/singlecell-modes/data/negative-controls/klein_indrops_control.h5ad')
       scanpy.pp.filter_genes(x, min_counts=1)
       x = x[:,x.var.filter(like='ERCC', axis='index').index]
       return pd.DataFrame(x.X.A, index=x.obs.index, columns=x.var.index)

     def read_gemcode():
       x = scanpy.read('/project2/mstephens/aksarkar/projects/singlecell-modes/data/negative-controls/zheng_gemcode_control.h5ad')
       scanpy.pp.filter_genes(x, min_counts=1)
       return pd.DataFrame(x.X.A, index=x.obs.index, columns=x.var.index)

     def read_c1(min_detect=1000):
       x = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/ercc-counts.txt.gz', sep='\t', index_col=0)
       keep_samples = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/quality-single-cells.txt', header=None, index_col=0, sep='\t')
       # Throw out samples with too few spike-in molecules detected
       return x.loc[:,np.logical_and((x.sum(axis=0) > min_detect).values, keep_samples.values.ravel())].T

     def _mix_10x(k1, k2, min_detect=0.01, return_y=False):
       x1 = scmodes.dataset.read_10x(f'/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/{k1}/filtered_matrices_mex/hg19/', return_df=True, min_detect=0)
       x2 = scmodes.dataset.read_10x(f'/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/{k2}/filtered_matrices_mex/hg19/', return_df=True, min_detect=0)
       x, y = scmodes.dataset.synthetic_mix(x1, x2, min_detect=min_detect)
       if return_y:
         return x, y
       else:
         return x

     def _cd8_cd19_mix(**kwargs):
       return _mix_10x('cytotoxic_t', 'b_cells', **kwargs)

     def _cyto_naive_mix(**kwargs):
       return _mix_10x('cytotoxic_t', 'naive_t', **kwargs)

     def _read_10x(k):
       return scmodes.dataset.read_10x(f'/project2/mstephens/aksarkar/projects/singlecell-ideas/data/10xgenomics/{k}/filtered_matrices_mex/hg19/',
                                       return_df=True, min_detect=0.01)

     data = {
       'dropseq': read_dropseq,
       'indrops': read_indrops,
       'chromium1': lambda: read_chromium('20311'),
       'chromium2': lambda: read_chromium('20312'),
       'gemcode': read_gemcode,
       'c1': read_c1,
       'cytotoxic_t': lambda: _read_10x('cytotoxic_t'),
       'b_cells': lambda: _read_10x('b_cells'),
       'ipsc': lambda: scmodes.dataset.ipsc('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/', return_df=True),
       'cytotoxic_t-b_cells': _cd8_cd19_mix,
       'cytotoxic_t-naive_t': _cyto_naive_mix,
       # Important: subsample the cells
       'pbmcs_68k': lambda: _read_10x('fresh_68k_pbmc_donor_a').sample(n=20000, random_state=1),
     }
   #+END_SRC

   #+RESULTS: data
   :RESULTS:
   # Out[5]:
   :END:

   Report the dimensions of each data set.

   #+BEGIN_SRC ipython :async t
     pd.DataFrame([data[k]().shape for k in data],
                  columns=['num_cells', 'num_genes'],
                  index=data.keys())
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[6]:
   #+BEGIN_EXAMPLE
     num_cells  num_genes
     dropseq                     84         81
     indrops                    953        103
     chromium1                 2000         88
     chromium2                 2000         88
     gemcode                   1015         91
     c1                        5002         92
     cytotoxic_t              10209       6530
     b_cells                  10085       6417
     ipsc                      5597       9957
     cytotoxic_t-b_cells      20294       6647
     cytotoxic_t-naive_t      20688       6246
     pbmcs_68k                20000       6502
   #+END_EXAMPLE
   :END:

* Results
** Simulation
   :PROPERTIES:
   :CUSTOM_ID: simulation
   :END:

   Draw data following the Poisson-point Gamma distribution:

   \begin{align*}
     x_i &\sim \operatorname{Poisson}(s_i \lambda_i)\\
     \lambda_i &\sim \pi \delta_0(\cdot) + (1 - \pi) \operatorname{Gamma}(1/\phi, 1/(\mu\phi))
   \end{align*}

   Draw simulation parameters \(s_i=10^5, \ln\mu, \ln\phi\) from typical values
   (Sarkar et al. 2019).

   \begin{align*}
     \ln\mu &\sim \operatorname{Uniform}(-12, -8)\\
     \ln\phi &\sim \operatorname{Uniform}(-6, 0)
   \end{align*}

   Then, test for goodness of fit of Gamma, point-Gamma, and unimodal, each
   convolved with Poisson.

   #+BEGIN_SRC ipython
     import scmodes.benchmark.gof

     def trial(num_samples, logodds, seed, verbose=False):
       data, _ = scqtl.simulation.simulate(num_samples=num_samples, logodds=logodds, seed=seed)
       x = data[:,0]
       s = data[:,1]
       # Important: scqtl.simple returns mu, 1/phi
       fit0 = scqtl.simple.fit_nb(x, s)
       res0 = scmodes.benchmark.gof._gof(x, cdf=scmodes.benchmark.gof._zig_cdf,
                                         pmf=scmodes.benchmark.gof._zig_pmf, size=s,
                                         log_mu=np.log(fit0[0]), log_phi=-np.log(fit0[1]))
       fit1 = scqtl.simple.fit_zinb(x, s)
       res1 = scmodes.benchmark.gof._gof(x, cdf=scmodes.benchmark.gof._zig_cdf,
                                         pmf=scmodes.benchmark.gof._zig_pmf, size=s,
                                         log_mu=np.log(fit1[0]), log_phi=-np.log(fit1[1]), logodds=fit1[2])

       # Important: this returns the gene name as the first return value
       res2 = scmodes.benchmark.gof._gof_unimodal('gene', pd.Series(x), pd.Series(s))
       return res0[1], res1[1], res2[2]

     def evaluate(num_samples, num_trials):
       result = []
       for logodds in np.linspace(-5, 0, 10):
         for seed in range(num_trials):
           gamma_res, zig_res, unimodal_res = trial(num_samples, logodds, seed)
           result.append([logodds, seed, gamma_res, zig_res, unimodal_res])
       result = pd.DataFrame(result)
       result.columns = ['logodds', 'trial', 'gamma', 'zig', 'unimodal']
       return result
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[7]:
   :END:

   Run the simulation.

   #+BEGIN_SRC ipython :async t
     sim_res = evaluate(num_samples=1000, num_trials=10)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[8]:
   :END:

   Write out the results.

   #+BEGIN_SRC ipython :async t
     sim_res.to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/gof/simulation.txt.gz', sep='\t', compression='gzip')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[9]:
   :END:

   Read the results.

   #+BEGIN_SRC ipython
     sim_res = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/gof/simulation.txt.gz', sep='\t', compression='gzip', index_col=0)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[5]:
   :END:

   Plot the results.

   #+BEGIN_SRC ipython :ipyfile figure/gof.org/sim.png
     cm = plt.get_cmap('Dark2')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i, (k, l) in enumerate(zip(['gamma', 'zig', 'unimodal'], ['Gamma', 'ZIG', 'Unimodal'])):
       jitter = np.random.normal(scale=0.01, size=sim_res.shape[0])
       plt.scatter(sim_res['logodds'] + jitter, -np.log10(sim_res[k] + 1e-100), s=2, c=np.atleast_2d(cm(i)), label=l)
     plt.axhline(y=0, c='k', lw=1)
     plt.axhline(y=-np.log10(.05), c='0.8', ls='--', lw=1)
     plt.legend(frameon=False, handletextpad=0, markerscale=4)
     plt.xticks(np.linspace(-5, 0, 10), [f'{x:.2g}' for x in sp.expit(np.linspace(-5, 0, 10))], rotation=90)
     plt.xlabel('$\pi$')
     plt.ylabel('Goodness of fit $-\log_{10}(p)$')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[6]:
   [[file:figure/gof.org/sim.png]]
   :END:

   Plot a zoomed-in version of the results.

   #+BEGIN_SRC ipython :ipyfile figure/gof.org/sim-inset.png
     cm = plt.get_cmap('Dark2')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i, (k, l) in enumerate(zip(['gamma', 'zig', 'unimodal'], ['Gamma', 'ZIG', 'Unimodal'])):
       jitter = np.random.normal(scale=0.01, size=sim_res.shape[0])
       plt.scatter(sim_res['logodds'] + jitter, -np.log10(sim_res[k] + 1e-100), s=2, c=np.atleast_2d(cm(i)), label=l)
     plt.axhline(y=0, c='k', lw=1)
     plt.axhline(y=-np.log10(.05), c='0.8', ls='--', lw=1)
     plt.legend(frameon=False, handletextpad=0, markerscale=4)
     plt.xticks(np.linspace(-5, 0, 10), [f'{x:.2g}' for x in sp.expit(np.linspace(-5, 0, 10))], rotation=90)
     plt.xlabel('$\pi$')
     plt.ylim(0, 10)
     plt.ylabel('Goodness of fit $-\log_{10}(p)$')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[7]:
   [[file:figure/gof.org/sim-inset.png]]
   :END:

** Test for goodness of fit
   :PROPERTIES:
   :CUSTOM_ID: gof
   :END:
*** Run the test

    Run the GPU-based methods.

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=gpu2 --gres=gpu:1 --mem=16G --job-name=gof --time=24:00:00 -a 11
      #!/bin/bash
      source activate scmodes
      python <<EOF
      <<imports>>
      import os
      <<data>>
      tasks = list(data.keys())
      task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
      x = data[task]()
      res = scmodes.benchmark.evaluate_gof(x, methods=['gamma', 'zig'])
      res.to_csv(f'/scratch/midway2/aksarkar/modes/gof/{task}-gpu.txt.gz', compression='gzip', sep='\t')
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 63768684

    Run the CPU methods.

    #+BEGIN_SRC sh :noweb eval :dir /scratch/midway2/aksarkar/modes/
      sbatch --partition=broadwl -n1 -c28 --exclusive --job-name=gof --time=24:00:00 -a 12-13
      #!/bin/bash
      source activate scmodes
      python <<EOF
      <<imports>>
      import multiprocessing as mp
      import os
      <<data>>
      tasks = list(data.keys())
      task = tasks[int(os.environ['SLURM_ARRAY_TASK_ID'])]
      with mp.Pool(maxtasksperchild=20) as pool:
        # Important: this needs to be done after initializing the pool to avoid
        # memory duplication
        x = data[task]()
        res = scmodes.benchmark.evaluate_gof(x, pool=pool, methods=['unimodal'])
        res.index = x.columns
        res.to_csv(f'/scratch/midway2/aksarkar/modes/gof/{task}-unimodal.txt.gz', compression='gzip', sep='\t')
      EOF
    #+END_SRC

    #+RESULTS:
    : Submitted batch job 63507410

    Move the results to permanent storage.

    #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/modes/
      rsync -au /scratch/midway2/aksarkar/modes/gof/ /project2/mstephens/aksarkar/projects/singlecell-modes/data/gof/
    #+END_SRC

    #+RESULTS:

    Read the results.

    #+BEGIN_SRC ipython
      gof_res = []
      for m in ['gpu', 'unimodal']:
        res = dict()
        for k in data:
          f = f'/project2/mstephens/aksarkar/projects/singlecell-modes/data/gof/{k}-{m}.txt.gz'
          if os.path.exists(f):
            # Hacks
            if k in ('pbmcs_68k_1', 'pbmcs_68k_2'):
              k = 'pbmcs_68k'
            res[k] = pd.read_csv(f, sep='\t', index_col=0)
            if 'gene.1' in res[k].columns:
              del res[k]['gene.1']
            if m == 'unimodal':
              res[k] = res[k].reset_index(drop=(res[k].index.name != 'gene'))
        gof_res.append(pd.concat(res, sort=True)
                       .reset_index(level=0)
                       .rename({'level_0': 'dataset'}, axis=1))
      gof_res = pd.concat(gof_res).reset_index(drop=True)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[19]:
    :END:

    Write out the post-processed results.

    #+BEGIN_SRC ipython
      gof_res.to_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/gof/gof.txt.gz', sep='\t', compression='gzip')
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[20]:
    :END:

    Read the post-processed results.

    #+BEGIN_SRC ipython
      gof_res = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-modes/data/gof/gof.txt.gz', sep='\t', index_col=0)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[6]:
    :END:

*** Control data sets

    Report the number of genes which depart from the null that the data for the
    gene follows the fitted distribution (after Bonferroni correction at level
    0.05).

    #+BEGIN_SRC ipython
      control = list(data.keys())[:5]
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[21]:
    :END:

    #+BEGIN_SRC ipython
      (gof_res[gof_res['dataset'].isin(control)]
       .groupby(['dataset', 'method'])
       .apply(lambda x: (x['p'] < 0.05 / x.shape[0]).sum())
       .reset_index()
       .pivot(index='dataset', columns='method'))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[22]:
    #+BEGIN_EXAMPLE
      0
      method    gamma unimodal zig
      dataset
      chromium1     3        0   3
      chromium2     0        0   0
      dropseq       0        0   0
      gemcode      20        0  21
      indrops       0        0   0
    #+END_EXAMPLE
    :END:

    Plot the histogram of goodness of fit test \(p\)-values for the fitted Gamma
    distributions for each control dataset.

    #+BEGIN_SRC ipython :ipyfile figure/gof.org/control-gamma-gof-hist.png
      plt.clf()
      fig, ax = plt.subplots(1, 5, sharey=True)
      fig.set_size_inches(7, 2)
      for a, (k, g) in zip(ax.ravel(),
                           gof_res.loc[gof_res['dataset'].isin(control)].groupby('dataset')):
        a.hist(g.loc[g['method'] == 'gamma', 'p'], bins=np.linspace(0, 1, 11), color='0.7', density=True)
        a.axhline(y=1, c='k', ls=':', lw=1)
        a.set_xlim([0, 1])
        a.set_title(k)
      ax[0].set_ylabel('Density')
      for a in ax:
        a.set_xlabel('$p$-value')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[21]:
    [[file:figure/gof.org/control-gamma-gof-hist.png]]
    :END:

    Plot the histogram of goodness of fit test \(p\)-values for the fitted point-Gamma
    distributions for each control dataset.

    #+BEGIN_SRC ipython :ipyfile figure/gof.org/control-zig-gof-hist.png
      plt.clf()
      fig, ax = plt.subplots(1, 5, sharey=True)
      fig.set_size_inches(7, 2)
      for a, (k, g) in zip(ax.ravel(),
                           gof_res.loc[gof_res['dataset'].isin(control)].groupby('dataset')):
        a.hist(g.loc[g['method'] == 'zig', 'p'], bins=np.linspace(0, 1, 11), color='0.7', density=True)
        a.axhline(y=1, c='k', ls=':', lw=1)
        a.set_xlim([0, 1])
        a.set_title(k)
      ax[0].set_ylabel('Density')
      for a in ax.T:
        a.set_xlabel('$p$-value')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[24]:
    [[file:figure/gof.org/control-zig-gof-hist.png]]
    :END:

    Plot the histogram of goodness of fit test \(p\)-values for the fitted unimodal
    distributions for each control dataset.

    #+BEGIN_SRC ipython :ipyfile figure/gof.org/control-unimodal-gof-hist.png
      plt.clf()
      fig, ax = plt.subplots(1, 5, sharey=True)
      fig.set_size_inches(7, 2)
      for a, (k, g) in zip(ax.ravel(),
                           gof_res.loc[gof_res['dataset'].isin(control)].groupby('dataset')):
        a.hist(g.loc[g['method'] == 'unimodal', 'p'], bins=np.linspace(0, 1, 11), color='0.7', density=True)
        a.axhline(y=1, c='k', ls=':', lw=1)
        a.set_xlim([0, 1])
        a.set_title(k)
      ax[0].set_ylabel('Density')
      for a in ax:
        a.set_xlabel('$p$-value')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[25]:
    [[file:figure/gof.org/control-unimodal-gof-hist.png]]
    :END:

*** Biological data sets

    #+BEGIN_SRC ipython
      non_control = list(data.keys())[6:12]
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[23]:
    :END:

    Plot the histogram of goodness of fit test \(p\)-values for the fitted Gamma
    distribution.

    #+BEGIN_SRC ipython :ipyfile figure/gof.org/gamma-gof-hist.png
      plt.clf()
      fig, ax = plt.subplots(1, 6, sharey=True)
      fig.set_size_inches(8, 2)
      for a, t, (k, g) in zip(ax.ravel(),
                              ['T cell', 'B cell', 'iPSC', 'T cell/B cell', 'Cytotoxic/naive T', 'PBMC'],
                              gof_res.groupby('dataset')):
        a.hist(g.loc[g['method'] == 'gamma', 'p'], bins=np.linspace(0, 1, 11), color='0.7', density=True)
        a.axhline(y=1, c='k', ls=':', lw=1)
        a.set_xlim([0, 1])
        a.set_title(t)
      ax[0].set_ylabel('Density')
      for a in ax:
        a.set_xlabel('$p$-value')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[24]:
    [[file:figure/gof.org/gamma-gof-hist.png]]
    :END:

    Plot the histogram of goodness of fit test \(p\)-values for the fitted
    point-Gamma distribution.

    #+BEGIN_SRC ipython :ipyfile figure/gof.org/zig-gof-hist.png
      plt.clf()
      fig, ax = plt.subplots(1, 6, sharey=True)
      fig.set_size_inches(8, 2)
      for a, t, (k, g) in zip(ax.ravel(),
                              ['T cell', 'B cell', 'iPSC', 'T cell/B cell', 'Cytotoxic/naive T', 'PBMC'],
                              gof_res.groupby('dataset')):
        a.hist(g.loc[g['method'] == 'zig', 'p'], bins=np.linspace(0, 1, 11), color='0.7', density=True)
        a.axhline(y=1, c='k', ls=':', lw=1)
        a.set_xlim([0, 1])
        a.set_title(t)
      ax[0].set_ylabel('Density')
      for a in ax:
        a.set_xlabel('$p$-value')
      fig.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[26]:
    [[file:figure/gof.org/zig-gof-hist.png]]
    :END:

    Report the number of genes which do not depart from the null that the data
    for the gene follows the fitted distribution (after Bonferroni correction
    at level 0.05).

    #+BEGIN_SRC ipython
      (gof_res.loc[gof_res['dataset'].isin(list(data.keys())[6:])]
       .groupby(['dataset', 'method'])
       .apply(lambda x: (x['p'] >= 0.05 / x.shape[0]).sum())
       .reset_index()
       .pivot(index='dataset', columns='method'))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[30]:
    #+BEGIN_EXAMPLE
      0
      method                gamma unimodal     zig
      dataset
      b_cells              6408.0    499.0  6409.0
      cytotoxic_t          6524.0    500.0  6524.0
      cytotoxic_t-b_cells  6613.0    491.0  6629.0
      cytotoxic_t-naive_t  6226.0    496.0  6227.0
      ipsc                 9799.0    498.0  9802.0
      pbmcs_68k            6458.0      NaN  6468.0
    #+END_EXAMPLE
    :END:

    Report the fraction of genes which do not depart from the null that the
    data for the gene follows the fitted distribution (after Bonferroni
    correction at level 0.05).

    #+BEGIN_SRC ipython
      (gof_res.loc[gof_res['dataset'].isin(list(data.keys())[6:])]
       .groupby(['dataset', 'method'])
       .apply(lambda x: (x['p'] > 0.05 / x.shape[0]).mean())
       .reset_index()
       .pivot(index='dataset', columns='method'))
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[31]:
    #+BEGIN_EXAMPLE
      0
      method                  gamma unimodal       zig
      dataset
      b_cells              0.998597    0.998  0.998753
      cytotoxic_t          0.999081    1.000  0.999081
      cytotoxic_t-b_cells  0.994885    0.982  0.997292
      cytotoxic_t-naive_t  0.996798    0.992  0.996958
      ipsc                 0.984132    0.996  0.984433
      pbmcs_68k            0.993233      NaN  0.994771
    #+END_EXAMPLE
    :END:

    *Remark* We previously fit point-Gamma distributions to the iPSC data
    (Sarkar et al. 2019), and [[https://jdblischak.github.io/singlecell-qtl/zinb.html#org17af587][reported]]:

    #+BEGIN_QUOTE
    We tested the goodness of fit for each individual and each gene, and
    rejected the null that the model fit the data for only 60 of 537,658
    individual-gene combinations (0.01%) after Bonferroni correction ($p < 9
    \times 10^{−8}$)
    #+END_QUOTE

    The key difference between the approach taken here and the previous result
    is that here we do not account for the fact that the cells are derived from
    multiple donors. The differing genetic backgrounds of the donor individuals
    means both the mean and variance of gene expression vary, such that the
    marginal distribution is not well-described by a single Gamma distribution.

** Examples
   :PROPERTIES:
   :CUSTOM_ID: examples
   :END:

   Read gene metadata.

   #+BEGIN_SRC ipython
     gene_info = pd.read_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-genes.txt.gz', sep='\t', index_col=0)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[30]:
   :END:

   Populate the database to visualize all of the results.

   #+BEGIN_SRC ipython
     sig = gof_res.groupby(['method', 'dataset']).apply(lambda x: x.loc[x['p'] < 0.05 / x.shape[0]]).reset_index(drop=True)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[24]:
   :END:

   #+BEGIN_SRC ipython :async t
     keys = []
     counts = []
     for k, g in sig.groupby(['dataset']):
       x = data[k]()
       query = g['gene'].unique()
       counts.append(x[query])
       keys.append(k)

     def _melt(y):
       y.index.name = 'sample'
       return (y
               .reset_index()
               .melt(id_vars='sample', var_name='gene', value_name='count'))

     count_data = pd.concat([_melt(y) for y in counts], keys=keys).reset_index(level=0).rename({'level_0': 'dataset'}, axis=1)
   #+END_SRC

   #+BEGIN_SRC ipython :async t
     with sqlite3.connect('/project2/mstephens/aksarkar/projects/singlecell-modes/browser/browser.db') as conn:
       sig.to_sql('genes', conn, if_exists='replace', index=False)
       conn.execute('create index genes_idx on genes(dataset, gene);')
       count_data.to_sql('counts', conn, if_exists='replace', index=False)
       conn.execute('create index counts_idx on counts(dataset, gene);')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[69]:
   :END:

   Look at genes which significantly depart from Gamma, but not from
   point-Gamma.

   #+BEGIN_SRC ipython
     sig0 = gof_res[gof_res['method'] == 'gamma'].groupby('dataset').apply(lambda x: x.loc[x['p'] < 0.05 / x.shape[0]]).reset_index(drop=True)
     nsig1 = gof_res[gof_res['method'] == 'zig'].groupby('dataset').apply(lambda x: x.loc[x['p'] >= 0.05 / x.shape[0]]).reset_index(drop=True)
     examples = sig0.merge(nsig1, on=['dataset', 'gene'], suffixes=['_gamma', '_zig'])
     del examples['method_gamma']
     del examples['method_zig']
     examples = examples.groupby('dataset').apply(pd.DataFrame.sort_values, 'p_gamma').reset_index(drop=True)
     examples['name'] = gene_info.loc[examples['gene'], 'name'].reset_index(drop=True)
     examples
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[36]:
   #+BEGIN_EXAMPLE
     dataset             gene       p_gamma  stat_gamma     p_zig  \
     0               b_cells  ENSG00000145425  1.915091e-05    0.023936  0.000103
     1           cytotoxic_t  ENSG00000077984  4.945356e-05    0.022793  0.420865
     2           cytotoxic_t  ENSG00000145649  7.289148e-05    0.022372  0.608038
     3   cytotoxic_t-b_cells  ENSG00000198502  1.442417e-85    0.069499  0.079374
     4   cytotoxic_t-b_cells  ENSG00000128218  3.617516e-06    0.018049  0.001558
     5                  ipsc  ENSG00000112530  7.841127e-20    0.063182  0.010855
     6                  ipsc  ENSG00000109736  2.153803e-05    0.031967  0.000116
     7             pbmcs_68k  ENSG00000008517  9.342086e-79    0.036263  0.000774
     8             pbmcs_68k  ENSG00000011600  7.884402e-39    0.025391  0.089060
     9             pbmcs_68k  ENSG00000100453  2.838638e-35    0.024187  0.485551
     10            pbmcs_68k  ENSG00000100450  5.431306e-22    0.019028  0.632199
     11            pbmcs_68k  ENSG00000198502  1.865120e-06    0.010062  0.687567
     12            pbmcs_68k  ENSG00000126264  1.633343e-05    0.009242  0.000796
     13            pbmcs_68k  ENSG00000197540  8.630388e-05    0.008560  0.000194

     stat_zig      name
     0   0.022120     RPS3A
     1   0.008710      CST7
     2   0.007536      GZMA
     3   0.008916  HLA-DRB5
     4   0.013280    VPREB3
     5   0.021587     PACRG
     6   0.029518    MFSD10
     7   0.007569      IL32
     8   0.004763    TYROBP
     9   0.003195      GZMB
     10  0.002853      GZMH
     11  0.002727  HLA-DRB5
     12  0.007555      HCST
     13  0.008209      GZMM
   #+END_EXAMPLE
   :END:

   Look at genes which depart from both point-Gamma and unimodal.

   #+BEGIN_SRC ipython
     sig0 = gof_res[gof_res['method'] == 'zig'].groupby('dataset').apply(lambda x: x.loc[x['p'] < 0.05 / x.shape[0]]).reset_index(drop=True)
     sig1 = gof_res[gof_res['method'] == 'unimodal'].groupby('dataset').apply(lambda x: x.loc[x['p'] < 0.05 / x.shape[0]]).reset_index(drop=True)
     examples = sig0.merge(sig1, on=['dataset', 'gene'], suffixes=['_zig', '_unimodal'])
     del examples['method_zig']
     del examples['method_unimodal']
     examples
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[12]:
   #+BEGIN_EXAMPLE
     dataset             gene          p_zig  stat_zig  \
     0               b_cells  ENSG00000177954   1.899033e-19  0.046600
     1   cytotoxic_t-b_cells  ENSG00000156738   9.244853e-05  0.015682
     2   cytotoxic_t-b_cells  ENSG00000166710   1.277500e-21  0.034675
     3   cytotoxic_t-b_cells  ENSG00000139193   1.673955e-08  0.021406
     4   cytotoxic_t-b_cells  ENSG00000109971   4.144996e-05  0.016300
     5   cytotoxic_t-b_cells  ENSG00000233927   5.424448e-05  0.016096
     6   cytotoxic_t-b_cells  ENSG00000177954   1.925536e-17  0.031070
     7   cytotoxic_t-b_cells  ENSG00000196126   8.155849e-12  0.025419
     8   cytotoxic_t-naive_t  ENSG00000241343   2.619446e-07  0.019571
     9   cytotoxic_t-naive_t  ENSG00000149806   5.152087e-05  0.015981
     10  cytotoxic_t-naive_t  ENSG00000100316   3.397394e-13  0.026658
     11                 ipsc  ENSG00000057657   4.052158e-06  0.034221
     12            pbmcs_68k  ENSG00000070756   7.642401e-08  0.011159
     13            pbmcs_68k  ENSG00000140988  3.026495e-116  0.044095
     14            pbmcs_68k  ENSG00000186468   7.692682e-05  0.008609
     15            pbmcs_68k  ENSG00000234745   4.172440e-08  0.011355
     16            pbmcs_68k  ENSG00000168028   8.749574e-06  0.009485
     17            pbmcs_68k  ENSG00000145425   2.198793e-32  0.023163

     p_unimodal  stat_unimodal
     0   6.820167e-12       0.036181
     1   1.115665e-08       0.021639
     2   1.367186e-05       0.017118
     3   1.479537e-08       0.021477
     4   2.715650e-05       0.016617
     5   2.660919e-05       0.016632
     6   6.537640e-07       0.019182
     7   1.073144e-32       0.042787
     8   1.336271e-07       0.019982
     9   6.047701e-05       0.015859
     10  1.430774e-07       0.019941
     11  2.566220e-09       0.042767
     12  2.374435e-09       0.012241
     13  6.159689e-05       0.008703
     14  2.660201e-05       0.009048
     15  2.328378e-08       0.011541
     16  4.114968e-08       0.011360
     17  9.735004e-06       0.009444
   #+END_EXAMPLE
   :END:

