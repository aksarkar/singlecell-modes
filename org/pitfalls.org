#+TITLE: Common pitfalls in estimating the number of modes of gene expression
#+SETUPFILE: setup.org

* Setup                                                            :noexport:

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(venv="singlecell") :dir /scratch/midway2/aksarkar/modes/

  #+RESULTS:
  :RESULTS:
  Submitted batch job 49822119
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])

    import colorcet
    import gzip
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import scipy.stats as st
    import sklearn.mixture as skm

    import rpy2.robjects.packages
    import rpy2.robjects.pandas2ri
    import rpy2.robjects.numpy2ri

    rpy2.robjects.pandas2ri.activate()
    rpy2.robjects.numpy2ri.activate()
    mclust = rpy2.robjects.packages.importr('mclust')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[1]:
  :END:

* Joint distribution of expression across genes

  Reproduce [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4112276/bin/nihms-590625-f0001.jpg][Fig 1C]] of [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4112276/][Kharchenko et al 2014]]. They analyzed scRNA-Seq of mouse
  embryonic fibroblast cells generated by [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3129258/][Islam et al 2011]].

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/modes/
    curl -s -o GSE29087_L139_expression_tab.txt.gz "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE29087&format=file&file=GSE29087_L139_expression_tab.txt.gz"
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  Parse the data.

  #+NAME: parse-islam
  #+BEGIN_SRC ipython
    with gzip.open('/scratch/midway2/aksarkar/modes/GSE29087_L139_expression_tab.txt.gz', 'rt') as f:
      next(f)  # first three lines are description
      next(f)
      next(f)
      barcodes = next(f).split()
      samples = next(f).split()
      next(f)  # skip header
      features = []
      counts = []
      for line in f:
        row = line.split('\t')
        features.append(row[:6])
        counts.append([int(x) if x else np.nan for x in row[6:]])
      counts = np.ma.masked_invalid(np.array(counts).T)
  #+END_SRC

  #+RESULTS: parse-islam
  :RESULTS:
  # Out[2]:
  :END:

  #+RESULTS:
  :RESULTS:
  # Out[37]:
  :END:

  Plot the joint distribution of \(\log_2\) expression values across a pair of
  cells.

  #+BEGIN_SRC ipython
    def plot_joint_dist_two_cells(x, y):
      x = np.log(x + 1) / np.log(2)
      y = np.log(y + 1) / np.log(2)
      plt.clf()
      plt.gcf().set_size_inches(3, 3)
      plt.scatter(x, y, c='k', s=1)
      plt.axis('equal')
      plt.xlabel('$\log_2(r + 1)$ of cell 1')
      plt.ylabel('$\log_2(r + 1)$ of cell 2')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[57]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/islam-mef.png
    plot_joint_dist_two_cells(counts[1], counts[2])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[58]:
  [[file:figure/pitfalls.org/islam-mef.png]]
  :END:

  Now, simulate count data, assuming 25,000 molecules per
  cell and a range of parameters [[https://users.rcc.uchicago.edu/~aksarkar/singlecell-qtl/figure/zinb.org/joint-distribution.png][matching real data]]:

  \[ r_{ij} \sim \mathrm{Poisson}(R_i \lambda_{ij}) \]

  \[ \lambda_{ij} \sim \mathrm{Gamma}(\mu, \phi) \]

  #+BEGIN_SRC ipython
    def simulate_counts(num_cells, num_genes, size, nb=False, zi=False, seed=None):
      if seed is not None:
        np.random.seed(seed)
      mu = np.exp(np.random.uniform(-15, -4, size=(1, num_genes)))
      if nb:
        phi = np.exp(np.random.uniform(-4, 1, size=(1, num_genes)))
        u = np.random.gamma(phi, phi, size=(num_cells, num_genes))
      else:
        u = 1
      x = np.random.poisson(lam=size * mu * u, size=(num_cells, num_genes))
      return x
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[52]:
  :END:

  First, simulate Poisson data.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/pois.png
    x, y = simulate_counts(num_cells=2, num_genes=10000, size=2.5e4, seed=0)
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(np.log(x + 1) / np.log(2), np.log(y + 1) / np.log(2), c='k', s=1)
    plt.xlabel('$\log_2(r + 1)$ of cell 1')
    _ = plt.ylabel('$\log_2(r + 1)$ of cell 2')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[59]:
  [[file:figure/pitfalls.org/pois.png]]
  :END:

  Now, simulate negative binomial data.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/nb.png
    x, y = simulate_counts(num_cells=2, num_genes=10000, size=2.5e4, nb=True, seed=0)
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(np.log(x + 1) / np.log(2), np.log(y + 1) / np.log(2), c='k', s=1)
    plt.xlabel('$\log_2(r + 1)$ of cell 1')
    _ = plt.ylabel('$\log_2(r + 1)$ of cell 2')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[60]:
  [[file:figure/pitfalls.org/nb.png]]
  :END:

  The results suggest that the observed pattern of zeros in the joint
  distribution of genes across cells can arise simply from Poisson
  sampling. The observed outliers can be explained by overdispersion as well.

* Mode on zero

  Reproduce [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4112276/bin/nihms-590625-f0001.jpg][Fig. 1E]] of [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4112276/][Kharchenko et al 2014]]. We observed a similar
  relationship between \(\mathrm{logit}(\pi)\) and \(\ln\mu\) in iPSCs.

  #+BEGIN_SRC ipython
     log_mu = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz', index_col=0, sep=' ')
     log_phi = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz', index_col=0, sep=' ')
     logodds = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz', index_col=0, sep=' ')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[11]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/ipsc-zinb.png
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    x, y = log_mu['NA18507'].align(logodds['NA18507'], join='inner')
    plt.scatter(x, y, c='k', s=1, alpha=0.25)
    plt.xlabel('$\ln(\mu)$')
    _ = plt.ylabel('$\mathrm{logit}(\pi)$')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[13]:
  [[file:figure/pitfalls.org/ipsc-zinb.png]]
  :END:

  Now, simulate Poisson data and compute the empirical fraction of zeros.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/pois-pi0.png
    x = simulate_counts(num_cells=1000, num_genes=10000, size=2.5e4, seed=2)
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(np.log(x.mean(axis=0) / 2.5e4), (x == 0).mean(axis=0), c='k', s=1, alpha=0.25)
    plt.xlabel('$\ln(\hat\mu)$')
    _ = plt.ylabel('Empirical fraction of zeros')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[66]:
  [[file:figure/pitfalls.org/pois-pi0.png]]
  :END:

  Do the same for negative binomial data.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/nb-pi0.png
    x = simulate_counts(num_cells=1000, num_genes=10000, size=2.5e4, nb=True, seed=2)
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(np.log(x.mean(axis=0) / 2.5e4), (x == 0).mean(axis=0), c='k', s=1, alpha=0.25)
    plt.xlabel('$\ln(\hat\mu)$')
    _ = plt.ylabel('Empirical fraction of zeros')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[67]:
  [[file:figure/pitfalls.org/nb-pi0.png]]
  :END:

  The results suggest that even non-zero inflated data will have a sigmoidal
  relationship between the fraction of zeros and mean expression. 

  However, the results also suggest that zero-inflation is needed to explain
  the particular shape of the dependence observed in real data.

* Distribution of log CPM across cells

  Reproduce [[https://media.springernature.com/lw785/springer-static/image/art%253A10.1186%252Fs13059-016-0927-y/MediaObjects/13059_2016_927_Fig1_HTML.gif][Fig 1C]] from [[https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0927-y#Sec13][Bacher and Kendziorski 2016]].  

  Data set /sc2/ is scRNA-Seq of hESCs generated in [[https://www.ncbi.nlm.nih.gov/pubmed/26301841][Leng et al 2015]].

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/modes/.
    curl -s -o GSE64016_H1andFUCCI_normalized_EC.csv.gz "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE64016&format=file&file=GSE64016_H1andFUCCI_normalized_EC.csv.gz"
  #+END_SRC

  #+RESULTS:

  #+BEGIN_SRC ipython
    leng_tpm = pd.read_table('/scratch/midway2/aksarkar/modes/GSE64016_H1andFUCCI_normalized_EC.csv.gz', sep=',', index_col=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[2]:
  :END:

  To estimate the number of modes, Bacher and Kendziorski fit a Gaussian
  mixture model to log-transformed expression, selecting the number of
  components which optimizes BIC.

  #+BEGIN_SRC ipython
    def naive_est_num_modes(x):
      x = np.log(x.mask(x == 0).dropna()).values.reshape(-1, 1)
      if x.shape[0] > 1:
        res = mclust.Mclust(x, verbose=False)
        return np.array(res.rx2('parameters').rx2('mean')).shape[0]
      else:
        return np.nan
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[3]:
  :END:

  #+BEGIN_SRC ipython :async t
    num_modes = (leng_tpm
                 .loc[(leng_tpm > 0).mean(axis=1) > 0.75]
                 .sample(n=1000, random_state=0)
                 .apply(naive_est_num_modes, axis=1))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[4]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/gmm-mode-hist.png
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.hist(num_modes, bins=np.arange(num_modes.dropna().max()), color='black')
    plt.xlabel('Number of modes')
    _ = plt.ylabel('Number of genes')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[5]:
  [[file:figure/pitfalls.org/gmm-mode-hist.png]]
  :END:

  Look at some examples.

  #+BEGIN_SRC ipython
    def plot_data_gmm(x):
      x = np.log(x.mask(x == 0).dropna()).values.reshape(-1, 1)
      res = mclust.Mclust(x, verbose=False)
      plt.clf()
      plt.gcf().set_size_inches(3, 3)
      grid = np.linspace(x.min(), x.max(), 100)
      plt.hist(x, color='.75', bins=50, density=True)
      means = np.array(res.rx2('parameters').rx2('mean')).reshape(-1, 1)
      variances = np.array(res.rx2('parameters').rx2('variance').rx2('sigmasq')).reshape(-1, 1)
      F = st.norm(loc=means, scale=np.sqrt(variances)).pdf(grid)
      for i, px in enumerate(F):
        plt.plot(grid, px, lw=1, label='Component {}'.format(i + 1), ls='--')
      weights = np.array(res.rx2('parameters').rx2('pro'))
      plt.plot(grid, weights.dot(st.norm(loc=means, scale=np.sqrt(variances)).pdf(grid)), label='Average density', lw=1, c='k')
      plt.legend(frameon=False, loc='center left', bbox_to_anchor=(1, .5))
      plt.xlabel('log TPM')
      _ = plt.ylabel('Density')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[32]:
  :END:

  /CDC6/ was reported as a gene showing cyclical gene expression through the
  cell cycle in the original study.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/gmm-cdc6.png
    plot_data_gmm(leng_tpm.loc['CDC6'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[34]:
  [[file:figure/pitfalls.org/gmm-cdc6.png]]
  :END:

  Look at the gene with the most estimated modes.

  #+BEGIN_SRC ipython
    num_modes.idxmax()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[17]:
  : 'SEPN1'
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/gmm-sepn1.png
    plot_data_gmm(leng_tpm.loc['SEPN1'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[36]:
  [[file:figure/pitfalls.org/gmm-sepn1.png]]
  :END:

  The results suggest that Gaussian mixture modeling of log-transformed data
  does not give the right answer. Further, they suggest that GMM overfits the
  data (despite optimizing BIC).
