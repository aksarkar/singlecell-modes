#+TITLE: Common pitfalls in estimating the number of modes of gene expression
#+SETUPFILE: setup.org

* Setup                                                            :noexport:

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(mem="4G",partition="mstephens",venv="singlecell") :dir /scratch/midway2/aksarkar/modes

  #+RESULTS:
  :RESULTS:
  Submitted batch job 51133345
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])

    import colorcet
    import gzip
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import scipy.stats as st
    import sklearn.neighbors as skn

    import rpy2.robjects.packages
    import rpy2.robjects.pandas2ri
    import rpy2.robjects.numpy2ri

    rpy2.robjects.pandas2ri.activate()
    rpy2.robjects.numpy2ri.activate()
    mclust = rpy2.robjects.packages.importr('mclust')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[1]:
  :END:

* Joint distribution of expression across genes

  Reproduce [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4112276/bin/nihms-590625-f0001.jpg][Fig 1C]] of [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4112276/][Kharchenko et al 2014]]. They analyzed scRNA-Seq of mouse
  embryonic fibroblast cells generated by [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3129258/][Islam et al 2011]].

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/modes/
    curl -s -o GSE29087_L139_expression_tab.txt.gz "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE29087&format=file&file=GSE29087_L139_expression_tab.txt.gz"
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC R :eval never
    islam_counts <- read.delim(gzfile('/scratch/midway2/aksarkar/modes/GSE29087_L139_expression_tab.txt.gz'), skip=6, header=F)
    x <- log10(islam_counts[,92] + 1)
    y <- log10(islam_counts[,93] + 1)
    keep <- x != 0 | y != 0
    png('temp.png', width=4, height=4, res=300, units="in")
    smoothScatter(x[keep],y[keep] )
    dev.off()
  #+END_SRC

  #+ATTR_HTML: :width 300
  file:figure/pitfalls.org/islam-smoothscatter.png

  Parse the data.

  #+NAME: parse-islam
  #+BEGIN_SRC ipython
    with gzip.open('/scratch/midway2/aksarkar/modes/GSE29087_L139_expression_tab.txt.gz', 'rt') as f:
      next(f)  # first three lines are description
      next(f)
      next(f)
      barcodes = next(f).split()
      samples = next(f).split()
      next(f)  # skip header
      features = []
      counts = []
      for line in f:
        row = line.split('\t')
        features.append(row[:6])
        counts.append([int(x) if x else np.nan for x in row[6:]])
      counts = np.ma.masked_invalid(np.array(counts).T)
  #+END_SRC

  #+RESULTS: parse-islam
  :RESULTS:
  # Out[2]:
  :END:

  Plot the joint distribution of \(\log_2\) expression values across a pair of
  cells.

  #+BEGIN_SRC ipython
    def plot_joint_dist_two_cells(x, y):
      x = np.log(x + 1) / np.log(2)
      y = np.log(y + 1) / np.log(2)
      keep = (x + y) > 0

      plt.clf()
      plt.gcf().set_size_inches(3, 3)
      plt.hexbin(x[keep], y[keep], gridsize=25, bins='log', cmap=colorcet.cm['bgyw_r'])
      H, xx, yy = np.histogram2d(x[keep], y[keep], bins=30)
      gridx, gridy = np.meshgrid(xx[1:] + (xx[1] - xx[0]) / 2, yy[1:] + (yy[1] - yy[0]) / 2)
      low_pass = np.logical_and(H > 0, H < 3)
      plt.scatter(gridx[low_pass].ravel(), gridy[low_pass].ravel(), c='k', s=H[low_pass], alpha=0.5)

      plt.xlim([-0.5, 16])
      plt.ylim([-0.5, 16])
      plt.xticks(np.arange(0, 16, 5))
      plt.yticks(np.arange(0, 16, 5))
      plt.xlabel('$\log_2(r + 1)$ of cell 1')
      plt.ylabel('$\log_2(r + 1)$ of cell 2')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[148]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/islam-mef.png
    plot_joint_dist_two_cells(counts[91], counts[92])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[149]:
  [[file:figure/pitfalls.org/islam-mef.png]]
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/islam-mef-scatter.png
    x = np.log(counts[91] + 1) / np.log(2)
    y = np.log(counts[92] + 1) / np.log(2)
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(x, y, c='k', s=1, alpha=0.1)
    plt.axis('equal')
    plt.xlabel('$\log_2(r + 1)$ of cell 1')
    _ = plt.ylabel('$\log_2(r + 1)$ of cell 2')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[153]:
  [[file:figure/pitfalls.org/islam-mef-scatter.png]]
  :END:

  Now, simulate count data, assuming 25,000 molecules per
  cell and a range of parameters [[https://users.rcc.uchicago.edu/~aksarkar/singlecell-qtl/figure/zinb.org/joint-distribution.png][matching real data]]:

  \[ r_{ij} \sim \mathrm{Poisson}(R_i \lambda_{ij}) \]

  \[ \lambda_{ij} \sim \mathrm{Gamma}(\mu, \phi) \]

  #+BEGIN_SRC ipython
    def simulate_counts(num_cells, num_genes, size, nb=False, zi=False, seed=None):
      if seed is not None:
        np.random.seed(seed)
      mu = np.exp(np.random.uniform(-15, -4, size=(1, num_genes)))
      if nb:
        phi = np.exp(np.random.uniform(-4, 1, size=(1, num_genes)))
        u = np.random.gamma(phi, phi, size=(num_cells, num_genes))
      else:
        u = 1
      x = np.random.poisson(lam=size * mu * u, size=(num_cells, num_genes))
      return x
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[154]:
  :END:

  First, simulate Poisson data.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/pois.png
    x, y = simulate_counts(num_cells=2, num_genes=10000, size=2.5e4, seed=0)
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(np.log(x + 1) / np.log(2), np.log(y + 1) / np.log(2), c='k', s=1)
    plt.xlabel('$\log_2(r + 1)$ of cell 1')
    _ = plt.ylabel('$\log_2(r + 1)$ of cell 2')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[151]:
  [[file:figure/pitfalls.org/pois.png]]
  :END:

  Now, simulate negative binomial data.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/nb.png
    x, y = simulate_counts(num_cells=2, num_genes=10000, size=2.5e4, nb=True, seed=0)
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(np.log(x + 1) / np.log(2), np.log(y + 1) / np.log(2), c='k', s=1)
    plt.xlabel('$\log_2(r + 1)$ of cell 1')
    _ = plt.ylabel('$\log_2(r + 1)$ of cell 2')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[60]:
  [[file:figure/pitfalls.org/nb.png]]
  :END:

  The results suggest that the observed pattern of zeros in the joint
  distribution of genes across cells can arise simply from Poisson
  sampling. The observed outliers can be explained by overdispersion as well.

* Single cell/bulk concordance

  Reproduce Fig. 2 of [[https://academic.oup.com/biostatistics/article-lookup/doi/10.1093/biostatistics/kxx053][Hicks et al. 2017]] ([[https://github.com/stephaniehicks/scBatchPaper/blob/master/scripts/createFigures.Rmd][associated repository]]), which is Fig.
  1C of [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3683364/][Shalek et al. 2013]].

  Download the data.

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/ideas/.
    curl "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE41265&format=file&file=GSE41265_allGenesTPM.txt.gz" -o GSE41265_allGenesTPM.txt.gz
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  Read the data.

  #+BEGIN_SRC ipython 
    shalek_tpm = pd.read_table('/scratch/midway2/aksarkar/ideas/GSE41265_allGenesTPM.txt.gz')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[12]:
  :END:

  Shalek et al filtered genes that don't have TPM > 1 in at least three cells.

  #+BEGIN_SRC ipython
    shalek_tpm_pass = shalek_tpm.loc[((shalek_tpm.filter(like='S') > 1).sum(axis=1) >= 3).values]
    shalek_tpm_pass.shape
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[3]:
  : (6312, 22)
  :END:

  Plot 10K populations against each other.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/shalek-fig-1a.png
    plt.clf()
    fig, ax = plt.subplots(2, 2)
    fig.set_size_inches(6, 6)

    ax[0][0].scatter(np.log(shalek_tpm_pass['P1'] + 1), np.log(shalek_tpm_pass['P2'] + 1), c='k', s=2, alpha=0.1)
    ax[0][0].set_xlabel('Population 1 ln (TPM + 1)')
    ax[0][0].set_ylabel('Population 2 ln (TPM + 1)')

    ax[0][1].scatter(np.log(shalek_tpm_pass['P1'] + 1), np.log(shalek_tpm_pass['P3'] + 1), c='k', s=2, alpha=0.1)
    ax[0][1].set_xlabel('Population 1 ln (TPM + 1)')
    ax[0][1].set_ylabel('Population 3 ln (TPM + 1)')

    ax[1][0].scatter(np.log(shalek_tpm_pass['P2'] + 1), np.log(shalek_tpm_pass['P3'] + 1), c='k', s=2, alpha=0.1)
    ax[1][0].set_xlabel('Population 2 ln (TPM + 1)')
    ax[1][0].set_ylabel('Population 3 ln (TPM + 1)')

    ax[1][1].set_axis_off()
    fig.tight_layout()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[4]:
  [[file:figure/pitfalls.org/shalek-fig-1a.png]]
  :END:

  Plot the average single cell log (TPM + 1) against each 10K population log
  (TPM + 1)

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/shalek-fig-1c.png
    plt.clf()
    fig, ax = plt.subplots(1, 3)
    fig.set_size_inches(9, 3)
    for i, a in enumerate(ax):
      # Important: "When calculating the “average” single-cell expression level, we
      # first averaged TPM levels from each of the 18 single cells, and then
      # transformed this average estimate into log space." (Shalek et al 2013)
      a.scatter(np.log(shalek_tpm_pass.filter(like='S').mean(axis=1) + 1), np.log(shalek_tpm_pass[f'P{i + 1}'] + 1), s=2, alpha=0.1, c='k')
      a.plot([0, 12], [0, 12], c='r', lw=1)
      a.set_title(f'Population {i + 1}')
      a.set_xlabel('10K cells log (TPM + 1)')
    ax[0].set_ylabel('Single cell sample mean log (TPM + 1)')
    fig.tight_layout()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[5]:
  [[file:figure/pitfalls.org/shalek-fig-1c.png]]
  :END:

  Reproduce Fig. 2A of Hicks et al.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/hicks-fig-2a.png
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(np.log(shalek_tpm['P1'] + 1) / np.log(2), np.log(shalek_tpm.filter(like='S').mean(axis=1) + 1) / np.log(2), c='k', s=1, alpha=0.1)
    plt.plot([0, 10], [0, 10], c='r', lw=1)
    plt.xlabel('Population 1 $\log_2(\mathrm{TPM} + 1)$')
    plt.ylabel('Single cell mean $\log_2(\mathrm{TPM} + 1)$')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[15]:
  : Text(0,0.5,'Single cell mean $\\log_2(\\mathrm{TPM} + 1)$')
  [[file:figure/pitfalls.org/hicks-fig-2a.png]]
  :END:
  
  Reproduce Fig. 2B of Hicks et al. In their plotting code, they truncate the
  \(y\) limits to \([-5, 5]\), which actually cuts off some data.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/hicks-fig-2b.png
    plt.clf()
    fig, ax = plt.subplots(1, 3)
    fig.set_size_inches(8.5, 3)

    for i, a in enumerate(ax):
      M = (np.log(shalek_tpm.filter(like='S').mean(axis=1) + 1) / np.log(2) + np.log(shalek_tpm[f'P{i + 1}'] + 1) / np.log(2)) / 2
      A = np.log(shalek_tpm.filter(like='S').mean(axis=1) + 1) / np.log(2) - np.log(shalek_tpm[f'P{i + 1}'] + 1) / np.log(2)
      a.scatter(M, A, s=1, c='k', alpha=0.1)

      grid = np.linspace(0, M.max(), 25)
      a.plot(grid, A.groupby(np.digitize(M, bins=grid)).agg(np.mean), c='r', ls='--')

      a.set_title(f'Population {i + 1}')
      a.set_xlabel('M (mean average)')
      a.set_ylabel('A (log ratio)')
    fig.tight_layout()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[27]:
  [[file:figure/pitfalls.org/hicks-fig-2b.png]]
  :END:

  From these plots, Hicks et al. conclude that the single cell expression is
  systematically smaller than the bulk expression for lowly expressed genes.

  Now, TPM is proportional to relative abundance, where the constant of
  proportionality is constant across samples ([[https://dx.doi.org/10.1007/s12064-012-0162-3][Wagner et al. 2012]]). 

  However, it is still possible that TPM can be systematically different across
  many genes simply because some gene is highly expressed in one sample,
  altering the relative abundances of all other genes. Therefore, naive
  comparison of TPM could give misleading results.

  To investigate whether this is the case, instead plot relative abundances
  against each other.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/shalek-abundances.png
    plt.clf()
    fig, ax = plt.subplots(1, 3, sharex=True, sharey=True)
    fig.set_size_inches(9, 3)

    sc_mean_tpm = shalek_tpm.filter(like='S').mean(axis=1)
    sc_ln_abundance = np.ma.masked_invalid(np.log(sc_mean_tpm / sc_mean_tpm.sum()))
    lim = [-50,
           max(bulk_ln_abundance.max(), sc_ln_abundance.max())]

    for i, a in enumerate(ax):
      bulk_ln_abundance = np.ma.masked_invalid(np.log(shalek_tpm[f'P{i + 1}'] / shalek_tpm[f'P{i + 1}'].sum()))

      a.scatter(bulk_ln_abundance, sc_ln_abundance, s=1, c='0.75', alpha=0.1)

      outlier = np.where(np.logical_or(sc_ln_abundance < -30, bulk_ln_abundance < -30).filled(0))[0]
      a.scatter(bulk_ln_abundance[outlier], sc_ln_abundance[outlier], s=4, c='k')
      for o in outlier:
        a.text(bulk_ln_abundance[o], sc_ln_abundance[o], shalek_tpm.iloc[o]['GENE'])

      a.plot(lim, lim, c='r', lw=1)
      a.set_xlabel(f'Population {i + 1} ln relative abundance')
      ax[0].set_ylabel('Single cell ln relative abundance')
    fig.tight_layout()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[84]:
  [[file:figure/pitfalls.org/shalek-abundances.png]]
  :END:

  From these plots, we would conclude that the relative abundances in bulk are
  systematically smaller than in single cell, which is exactly the opposite of
  the conclusion in Hicks et al. 

  Our results are explained by the fact that exactly two genes, /ACAT3/ and
  /HSPA1B/, have systematically higher estimated abundance in bulk versus
  single cell.

  Reproduce Fig. 3 of Hicks et al. 2017. The data were generated in Shalek et
  al 2013, [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4122333/][Trapnell et al. 2014]], and [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4022966/][Wu et al. 2014]].

  Download the data generated by Trapnell et al.

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/ideas/
    curl "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE52529&format=file&file=GSE52529_fpkm_matrix.txt.gz" -o GSE52529_fpkm_matrix.txt.gz
    curl "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE52529&format=file&file=GSE52529_truseq_fpkm_matrix.txt.gz" -o GSE52529_truseq_fpkm_matrix.txt.gz
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  Download the data generated by Wu et al.

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/ideas/
    curl -O --ftp-pasv "ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE51nnn/GSE51254/suppl/GSE51254_RAW.tar"
    tar xf GSE51254_RAW.tar
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  Wu et al generated 2 bulk RNA-Seq replicates for each of two different
  technologies, and 96 scRNA-Seq libraries using the C1 platform.

  The RNA-Seq data were quantified using cufflinks. Concatenate the output to
  simplify parsing.
  
  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/ideas/
    zcat GSM*bulk*.sorted.genes.fpkm_tracking.txt.gz | cut -f10 | gzip >wu-bulk-fpkm.txt.gz
    zcat GSM*_C*_IL*.sorted.genes.fpkm_tracking.txt.gz | cut -f10 | gzip >wu-c1-fpkm.txt.gz
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  Read the data.

  #+BEGIN_SRC ipython
    trapnell_sc_fpkm = pd.read_table('/scratch/midway2/aksarkar/ideas/GSE52529_fpkm_matrix.txt.gz')
    trapnell_bulk_fpkm = pd.read_table('/scratch/midway2/aksarkar/ideas/GSE52529_truseq_fpkm_matrix.txt.gz')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[10]:
  :END:

  #+BEGIN_SRC ipython
    wu_bulk_fpkm = pd.read_table('/scratch/midway2/aksarkar/ideas/wu-bulk-fpkm.txt.gz', header=None).values.reshape(4, -1).T
    wu_sc_fpkm = pd.read_table('/scratch/midway2/aksarkar/ideas/wu-c1-fpkm.txt.gz', header=None).values.reshape(-1, wu_bulk_fpkm.shape[0]).T
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[86]:
  :END:

  Plot single cell mean against bulk expression. *Important: Hicks et al
  truncate the visualization.*

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/hicks-fig-3.png
    plt.clf()
    fig, ax = plt.subplots(1, 3)
    fig.set_size_inches(9, 3)

    ax[0].scatter(shalek_tpm['P1'], shalek_tpm.filter(like='S').mean(axis=1), s=1, c='k', alpha=0.1)
    ax[0].set_xlim(0, 30)
    ax[0].set_ylim(0, 30)
    grid = np.linspace(0, 30, 15)
    sm = shalek_tpm.filter(like='S').mean(axis=1).groupby(np.digitize(shalek_tpm['P1'], bins=grid)).agg(np.mean)
    ax[0].plot(grid[sm.index - 1], sm, c='r', lw=1, ls='--')


    ax[1].scatter(wu_bulk_fpkm[:,0], wu_sc_fpkm.mean(axis=1), s=1, c='k', alpha=0.1)
    ax[1].set_xlim(0, 50)
    ax[1].set_ylim(0, 50)
    grid = np.linspace(0, 30, 15)
    sm = pd.Series(wu_sc_fpkm.mean(axis=1)).groupby(np.digitize(wu_bulk_fpkm[:,0], bins=grid)).agg(np.mean)
    ax[1].plot(grid[sm.index - 1][1:], sm[1:], c='r', lw=1, ls='--')

    ax[2].scatter(trapnell_bulk_fpkm['T72_0'], trapnell_sc_fpkm.mean(axis=1), s=1, c='k', alpha=0.1)
    ax[2].set_xlim(0, 30)
    ax[2].set_ylim(0, 30)
    grid = np.linspace(0, 30, 15)
    sm = trapnell_sc_fpkm.mean(axis=1).groupby(np.digitize(trapnell_bulk_fpkm['T72_0'], bins=grid)).agg(np.mean)
    ax[2].plot(grid[sm.index - 1], sm, c='r', lw=1, ls='--')

    for a in ax:
      a.set_xlabel('Bulk TPM')
      a.set_ylabel('Single cell mean TPM')

    fig.tight_layout()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[96]:
  [[file:figure/pitfalls.org/hicks-fig-3.png]]
  :END:

  As we argued above, this comparison is not sensible. Instead, plot relative
  abundances against each other.

  #+BEGIN_SRC ipython
    def get_abundance(bulk, sc):
      bulk = np.ma.masked_values(bulk / bulk.sum(), 0)
      mean = sc.mean(axis=1)
      sc = np.ma.masked_values(mean / mean.sum(), 0)
      return bulk, sc

    shalek_bulk_abundance, shalek_sc_abundance = get_abundance(shalek_tpm['P1'], shalek_tpm.filter(like='S'))
    wu_bulk_abundance, wu_sc_abundance = get_abundance(wu_bulk_fpkm[:,0], wu_sc_fpkm)
    trapnell_bulk_abundance, trapnell_sc_abundance = get_abundance(trapnell_bulk_fpkm['T72_0'], trapnell_sc_fpkm)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[88]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/sc-bulk-abundance.png
    plt.clf()
    fig, ax = plt.subplots(1, 3, sharex=True, sharey=True)
    fig.set_size_inches(8, 3)

    lim = [5e-9, .1]
    ax[0].set_ylabel('Single cell mean relative abundance')
    for a in ax:
      a.set_xlabel('Bulk relative abundance')
      a.set_xscale('log')
      a.set_yscale('log')
      a.plot(lim, lim, c='r', lw=1)

    ax[0].scatter(shalek_bulk_abundance, shalek_sc_abundance, c='k', s=2, alpha=0.1)
    ax[0].set_title('Shalek et al.')

    ax[1].scatter(wu_bulk_abundance, wu_sc_abundance, c='k', s=1, alpha=0.1)
    ax[1].set_title('Wu et al.')

    ax[2].scatter(trapnell_bulk_abundance, trapnell_sc_abundance, c='k', s=1, alpha=0.1)
    ax[2].set_title('Trapnell et al.')

    fig.tight_layout()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[95]:
  [[file:figure/pitfalls.org/sc-bulk-abundance.png]]
  :END:

* Mode on zero

  Reproduce [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4112276/bin/nihms-590625-f0001.jpg][Fig. 1E]] of [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4112276/][Kharchenko et al 2014]]. We observed a similar
  relationship between \(\mathrm{logit}(\pi)\) and \(\ln\mu\) in iPSCs.

  #+BEGIN_SRC ipython
     log_mu = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz', index_col=0, sep=' ')
     log_phi = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz', index_col=0, sep=' ')
     logodds = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz', index_col=0, sep=' ')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[11]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/ipsc-zinb.png
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    x, y = log_mu['NA18507'].align(logodds['NA18507'], join='inner')
    plt.scatter(x, y, c='k', s=1, alpha=0.25)
    plt.xlabel('$\ln(\mu)$')
    _ = plt.ylabel('$\mathrm{logit}(\pi)$')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[13]:
  [[file:figure/pitfalls.org/ipsc-zinb.png]]
  :END:

  Now, simulate Poisson data and compute the empirical fraction of zeros.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/pois-pi0.png
    x = simulate_counts(num_cells=1000, num_genes=10000, size=2.5e4, seed=2)
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(np.log(x.mean(axis=0) / 2.5e4), (x == 0).mean(axis=0), c='k', s=1, alpha=0.25)
    plt.xlabel('$\ln(\hat\mu)$')
    _ = plt.ylabel('Empirical fraction of zeros')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[66]:
  [[file:figure/pitfalls.org/pois-pi0.png]]
  :END:

  Do the same for negative binomial data.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/nb-pi0.png
    x = simulate_counts(num_cells=1000, num_genes=10000, size=2.5e4, nb=True, seed=2)
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(np.log(x.mean(axis=0) / 2.5e4), (x == 0).mean(axis=0), c='k', s=1, alpha=0.25)
    plt.xlabel('$\ln(\hat\mu)$')
    _ = plt.ylabel('Empirical fraction of zeros')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[67]:
  [[file:figure/pitfalls.org/nb-pi0.png]]
  :END:

  The results suggest that even non-zero inflated data will have a sigmoidal
  relationship between the fraction of zeros and mean expression. 

  However, the results also suggest that zero-inflation is needed to explain
  the particular shape of the dependence observed in real data.

* Distribution of log CPM across cells

  Reproduce [[https://media.springernature.com/lw785/springer-static/image/art%253A10.1186%252Fs13059-016-0927-y/MediaObjects/13059_2016_927_Fig1_HTML.gif][Fig 1C]] from [[https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0927-y#Sec13][Bacher and Kendziorski 2016]].  

  Data set /sc2/ is scRNA-Seq of hESCs generated in [[https://www.ncbi.nlm.nih.gov/pubmed/26301841][Leng et al 2015]].

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/modes/.
    curl -s -o GSE64016_H1andFUCCI_normalized_EC.csv.gz "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE64016&format=file&file=GSE64016_H1andFUCCI_normalized_EC.csv.gz"
  #+END_SRC

  #+RESULTS:

  #+BEGIN_SRC ipython
    leng_tpm = pd.read_table('/scratch/midway2/aksarkar/modes/GSE64016_H1andFUCCI_normalized_EC.csv.gz', sep=',', index_col=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[2]:
  :END:

  To estimate the number of modes, Bacher and Kendziorski fit a Gaussian
  mixture model to log-transformed expression, selecting the number of
  components which optimizes BIC.

  #+BEGIN_SRC ipython
    def naive_est_num_modes(x):
      x = np.log(x.mask(x == 0).dropna()).values.reshape(-1, 1)
      if x.shape[0] > 1:
        res = mclust.Mclust(x, verbose=False)
        return np.array(res.rx2('parameters').rx2('mean')).shape[0]
      else:
        return np.nan
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[3]:
  :END:

  #+BEGIN_SRC ipython :async t
    num_modes = (leng_tpm
                 .loc[(leng_tpm > 0).mean(axis=1) > 0.75]
                 .sample(n=1000, random_state=0)
                 .apply(naive_est_num_modes, axis=1))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[4]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/gmm-mode-hist.png
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.hist(num_modes, bins=np.arange(num_modes.dropna().max()), color='black')
    plt.xlabel('Number of modes')
    _ = plt.ylabel('Number of genes')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[5]:
  [[file:figure/pitfalls.org/gmm-mode-hist.png]]
  :END:

  Look at some examples.

  #+BEGIN_SRC ipython
    def plot_data_gmm(x):
      x = np.log(x.mask(x == 0).dropna()).values.reshape(-1, 1)
      res = mclust.Mclust(x, verbose=False)
      plt.clf()
      plt.gcf().set_size_inches(3, 3)
      grid = np.linspace(x.min(), x.max(), 100)
      plt.hist(x, color='.75', bins=50, density=True)
      means = np.array(res.rx2('parameters').rx2('mean')).reshape(-1, 1)
      variances = np.array(res.rx2('parameters').rx2('variance').rx2('sigmasq')).reshape(-1, 1)
      F = st.norm(loc=means, scale=np.sqrt(variances)).pdf(grid)
      for i, px in enumerate(F):
        plt.plot(grid, px, lw=1, label='Component {}'.format(i + 1), ls='--')
      weights = np.array(res.rx2('parameters').rx2('pro'))
      plt.plot(grid, weights.dot(st.norm(loc=means, scale=np.sqrt(variances)).pdf(grid)), label='Average density', lw=1, c='k')
      plt.legend(frameon=False, loc='center left', bbox_to_anchor=(1, .5))
      plt.xlabel('log TPM')
      _ = plt.ylabel('Density')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[32]:
  :END:

  /CDC6/ was reported as a gene showing cyclical gene expression through the
  cell cycle in the original study.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/gmm-cdc6.png
    plot_data_gmm(leng_tpm.loc['CDC6'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[34]:
  [[file:figure/pitfalls.org/gmm-cdc6.png]]
  :END:

  Look at the gene with the most estimated modes.

  #+BEGIN_SRC ipython
    num_modes.idxmax()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[17]:
  : 'SEPN1'
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/gmm-sepn1.png
    plot_data_gmm(leng_tpm.loc['SEPN1'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[36]:
  [[file:figure/pitfalls.org/gmm-sepn1.png]]
  :END:

  The results suggest that Gaussian mixture modeling of log-transformed data
  does not give the right answer. Further, they suggest that GMM overfits the
  data (despite optimizing BIC).
* Pseudocount

  When computing log-transformed expression values, we need to introduce a
  pseudocount \(\epsilon\) to deal with observations of zero.

  Standard choices include \(\epsilon = 1\) and \(\epsilon = .5 / \bar{R}\),
  where \(\bar{R} = \frac{1}{n} \sum_i R_i\) ([[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3378882/][McCarthy et al 2012]]).

  Clearly, the pseudocount will introduce a mode at zero, even when the data is
  Poisson distributed.

  #+BEGIN_SRC ipython
    x = simulate_counts(num_cells=1000, num_genes=10000, size=1e5, seed=3)
    R = x.sum(axis=1)
    # Match edgeR
    eps = .5 / R.mean()
    y = (np.log(x + eps) - np.log(R.reshape(-1, 1) + 2 * eps) + 6 * np.log(10)) / np.log(2)
    # Get the simulated gene with most zeros
    idx = np.argmax((x == 0).mean(axis=0))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[172]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/log-cpm-modes.png
    plt.clf()
    fig, ax = plt.subplots(1, 2, sharey=True)
    fig.set_size_inches(5, 3)
    ax[0].hist(x[:,2], bins=np.arange(15), color='k')
    ax[0].plot(.5 + np.arange(15), 1000 * st.poisson(mu=x[:,2].mean()).pmf(np.arange(15)), lw=1, c='r')
    ax[0].set_xlabel('Molecule count')
    ax[0].set_ylabel('Number of cells')

    ax[1].hist(y[:,2], bins=30, color='k')
    ax[1].set_xlabel('$\log_2(\mathrm{CPM})$')
    fig.tight_layout()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[190]:
  [[file:figure/pitfalls.org/log-cpm-modes.png]]
  :END:
