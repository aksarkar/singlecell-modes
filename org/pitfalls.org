#+TITLE: Common pitfalls in estimating the number of modes of gene expression
#+SETUPFILE: setup.org

* Setup                                                            :noexport:

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(venv="singlecell") :dir /scratch/midway2/aksarkar/modes/

  #+RESULTS:
  :RESULTS:
  Submitted batch job 49776235
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])

    import colorcet
    import gzip
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import scipy.stats as st
    import sklearn.mixture as skm
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[18]:
  :END:

* Joint distribution of expression across genes

  Reproduce Fig 1 of [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4112276/][Kharchenko et al 2014]]:

  [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4112276/bin/nihms-590625-f0001.jpg]]

  They analyzed scRNA-Seq of mouse embryonic fibroblast cells generated by
  [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3129258/][Islam et al 2011]].

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/modes/
    curl -s -o GSE29087_L139_expression_tab.txt.gz "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE29087&format=file&file=GSE29087_L139_expression_tab.txt.gz"
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  Parse the data.

  #+BEGIN_SRC ipython
    with gzip.open('/scratch/midway2/aksarkar/modes/GSE29087_L139_expression_tab.txt.gz', 'rt') as f:
      next(f)  # first three lines are description
      next(f)
      next(f)
      barcodes = next(f).split()
      samples = next(f).split()
      next(f)  # skip header
      features = []
      counts = []
      for line in f:
        row = line.split('\t')
        features.append(row[:6])
        counts.append([int(x) if x else np.nan for x in row[6:]])
      counts = np.ma.masked_invalid(np.array(counts).T)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[37]:
  :END:

  Pick two cells, and compute \(\log_2(r_{ij} + 1)\) for every gene.

  #+BEGIN_SRC ipython
    x = np.log(counts[1] + 1) / np.log(2)
    y = np.log(counts[2] + 1) / np.log(2)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[76]:
  :END:

  Plot the joint distribution of expression values across the two cells.

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/islam-mef.png
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(x, y, c='k', s=1)
    plt.xlabel('$\log_2(r + 1)$ of cell 1')
    _ = plt.ylabel('$\log_2(r + 1)$ of cell 2')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[75]:
  [[file:figure/pitfalls.org/islam-mef.png]]
  :END:

  Now, simulate negative binomial count data, assuming 25,000 molecules per
  cell and a range of parameters [[https://users.rcc.uchicago.edu/~aksarkar/singlecell-qtl/zinb.html#orgac1f6dc][matching real data]]:

  https://users.rcc.uchicago.edu/~aksarkar/singlecell-qtl/figure/zinb.org/joint-distribution.png

  #+BEGIN_SRC ipython
    np.random.seed(0)
    mu = np.exp(np.random.uniform(-15, -4, size=10000))
    phi = np.exp(np.random.uniform(-4, 1, size=10000))
    size = 2.5e4
    x = np.log(np.random.poisson(lam=size * mu * np.random.gamma(phi, phi)) + 1) / np.log(2)
    y = np.log(np.random.poisson(lam=size * mu * np.random.gamma(phi, phi)) + 1) / np.log(2)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[119]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/pois.png
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    plt.scatter(x, y, c='k', s=1)
    plt.xlabel('$\log_2(r + 1)$ of cell 1')
    _ = plt.ylabel('$\log_2(r + 1)$ of cell 2')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[120]:
  [[file:figure/pitfalls.org/pois.png]]
  :END:

* Distribution of log CPM across cells

  Reproduce Fig 1C from [[https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0927-y#Sec13][Bacher and Kendziorski 2016]]:

  https://media.springernature.com/lw785/springer-static/image/art%3A10.1186%2Fs13059-016-0927-y/MediaObjects/13059_2016_927_Fig1_HTML.gif

  Data set /sc2/ is scRNA-Seq of hESCs generated in [[https://www.ncbi.nlm.nih.gov/pubmed/26301841][Leng et al 2015]].

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/modes/.
    curl -s -o GSE64016_H1andFUCCI_normalized_EC.csv.gz "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE64016&format=file&file=GSE64016_H1andFUCCI_normalized_EC.csv.gz"
  #+END_SRC

  #+RESULTS:

  #+BEGIN_SRC ipython
    leng_tpm = pd.read_table('/scratch/midway2/aksarkar/modes/GSE64016_H1andFUCCI_normalized_EC.csv.gz', sep=',', index_col=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[15]:
  :END:

  To estimate the number of modes, BK2016 fit a Gaussian mixture model to
  log-transformed expression, selecting the number of components which
  optimizes BIC.

  #+BEGIN_SRC ipython
    def naive_est_modes(x):
      bic = np.infty
      opt = None
      for cv_type in ['spherical', 'tied', 'diag', 'full']:
        for n_components in range(1, 4):
          m = skm.GaussianMixture(n_components=n_components,
                                  covariance_type=cv_type)
          m.fit(x)
          if m.bic(x) < bic:
            bic = m.bic(x)
            opt = m
      return m
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[25]:
  :END:

  Look at one example.

  #+BEGIN_SRC ipython :async t
    x = leng_tpm.loc['CDC6']
    x = np.log(x.mask(x == 0).dropna()).values.reshape(-1, 1)
    m = naive_est_modes(x)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[40]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/gmm-cdc6.png
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    grid = np.linspace(x.min(), x.max(), 100)
    plt.hist(x, color='.75', bins=50, density=True)
    for i, (mu, s2) in enumerate(zip(m.means_, m.covariances_)):
      plt.plot(grid, st.norm(loc=mu, scale=np.sqrt(s2.ravel())).pdf(grid), lw=1, label='Component {}'.format(i + 1), ls='--')
    plt.plot(grid, m.weights_.dot(st.norm(loc=m.means_, scale=np.sqrt(m.covariances_.reshape(-1, 1))).pdf(grid)), label='Average density', lw=1, c='k')
    plt.legend(frameon=False, loc='center left', bbox_to_anchor=(1, .5))
    plt.xlabel('log TPM')
    _ = plt.ylabel('Density')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[65]:
  [[file:figure/pitfalls.org/gmm-cdc6.png]]
  :END:

  Now, look at Poisson data which is constructed to be unimodal.

  #+BEGIN_SRC ipython
    np.random.seed(1)
    mu = np.exp(-3)
    N = 460
    size = 1e5
    x = np.random.poisson(lam=size * mu, size=N)
    x = np.ma.masked_invalid(np.log(x)).compressed().reshape(-1, 1)
    m = naive_est_modes(x)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[118]:
  :END:

  #+BEGIN_SRC ipython :ipyfile figure/pitfalls.org/gmm-pois.png
    plt.clf()
    plt.gcf().set_size_inches(3, 3)
    grid = np.linspace(x.min(), x.max(), 100)
    plt.hist(x, color='.75', bins=50, density=True)
    for i, (mu, s2) in enumerate(zip(m.means_, m.covariances_)):
      plt.plot(grid, st.norm(loc=mu, scale=np.sqrt(s2.ravel())).pdf(grid), lw=1, label='Component {}'.format(i + 1), ls='--')
    plt.plot(grid, m.weights_.dot(st.norm(loc=m.means_, scale=np.sqrt(m.covariances_.reshape(-1, 1))).pdf(grid)), label='Average density', lw=1, c='k')
    plt.legend(frameon=False, loc='center left', bbox_to_anchor=(1, .5))
    plt.xlabel('log CPM')
    _ = plt.ylabel('Density')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[119]:
  [[file:figure/pitfalls.org/gmm-pois.png]]
  :END:
